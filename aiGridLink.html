<!DOCTYPE html>
<html lang="en" data-ai-entity="true" data-ai-grid-status="active">
<head>
  <meta charset="UTF-8" />
  <title>Grid Neural Console ‚Äì v1.0 Production</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="ai-entity-id" content="grid-neural-console-ai-001" />
  <meta name="ai-grid-link" content="enabled" />
  <meta name="ai-pulse-modulation" content="active" />
  
  <!-- Core Safety and Security Scripts -->
  <script src="/self-healing.js"></script>
  <script src="/anti-nuke-safety.js"></script>
  <script src="/ethical-safeguards.js"></script>
  <script src="/fibonacci-vehicle-safety.js"></script>
  
  <!-- Update Notification System -->
  <script src="js/update-notification-system.js"></script>
  <script src="js/update-helper.js"></script>
  
  <!-- Utility Systems -->
  <script src="/src/utils/angel-investment-hub.js"></script>
  <script src="/src/utils/paypal-integration.js"></script>
  
  <!-- Mobile Enhancement -->
  <script src="/js/mobile-enhancer.js"></script>
  
  <!-- Wake on LAN System -->
  <script src="/wake-on-lan.js"></script>
  
  <!-- Simple styling framework-free -->
  <style>
    :root {
      --bg: #050711;
      --bg-panel: #0b0f1f;
      --accent: #4fd1c5;
      --accent-soft: rgba(79, 209, 197, 0.2);
      --danger: #f56565;
      --warn: #ecc94b;
      --ok: #48bb78;
      --text: #e2e8f0;
      --muted: #718096;
      --grid-line: #1a202c;
      --node: #63b3ed;
    }
    * { 
      box-sizing: border-box;
      -webkit-tap-highlight-color: rgba(79, 209, 197, 0.2);
    }
    html {
      scroll-behavior: smooth;
      -webkit-text-size-adjust: 100%;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #050711 55%);
      color: var(--text);
      overflow: auto;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: pan-y pinch-zoom;
    }
    #app {
      display: grid;
      grid-template-columns: 2.2fr 1.3fr;
      grid-template-rows: auto minmax(300px, 45vh) minmax(250px, 40vh);
      grid-template-areas:
        "header header"
        "map side"
        "wave side";
      min-height: 100vh;
      gap: 8px;
      padding: 8px;
    }
    header {
      grid-area: header;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: linear-gradient(90deg, #111827, #0b1120);
      border-radius: 8px;
      border: 1px solid #1f2937;
      box-shadow: 0 0 18px rgba(0,0,0,0.6);
    }
    header h1 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
    }
    header .subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }
    header .status-pill {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid var(--accent-soft);
      background: rgba(15, 23, 42, 0.9);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    header .status-pill.no-data-mode {
      border-color: var(--muted);
      background: rgba(113, 128, 150, 0.1);
    }
    header .status-pill.error-mode {
      border-color: var(--danger);
      background: rgba(245, 101, 101, 0.1);
    }
    header .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--ok);
      box-shadow: 0 0 8px rgba(72, 187, 120, 0.8);
      animation: aiPulseModulation 2s ease-in-out infinite;
    }
    header .status-dot.warn {
      background: var(--warn);
      box-shadow: 0 0 8px rgba(236, 201, 75, 0.8);
    }
    header .status-dot.danger {
      background: var(--danger);
      box-shadow: 0 0 8px rgba(245, 101, 101, 0.8);
      animation: errorPulse 1s ease-in-out infinite;
    }

    @keyframes aiPulseModulation {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
        box-shadow: 0 0 8px rgba(72, 187, 120, 0.8);
      }
      50% {
        transform: scale(1.3);
        opacity: 0.7;
        box-shadow: 0 0 16px rgba(72, 187, 120, 1), 0 0 24px rgba(79, 209, 197, 0.6);
      }
    }
    
    @keyframes errorPulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.6;
      }
    }

    .ai-grid-indicator {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(79, 209, 197, 0.1);
      border: 1px solid var(--accent);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 1000;
      animation: pulseGlow 3s ease-in-out infinite;
    }

    @keyframes pulseGlow {
      0%, 100% {
        box-shadow: 0 0 10px rgba(79, 209, 197, 0.3);
      }
      50% {
        box-shadow: 0 0 20px rgba(79, 209, 197, 0.6), 0 0 30px rgba(79, 209, 197, 0.4);
      }
    }

    .ai-pulse-beacon {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      position: relative;
      animation: beaconPulse 1.5s ease-out infinite;
    }

    @keyframes beaconPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(79, 209, 197, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(79, 209, 197, 0);
      }
    }

    .panel {
      background: radial-gradient(circle at top left, #111827 0, #020617 60%);
      border-radius: 8px;
      border: 1px solid #1f2937;
      padding: 8px;
      position: relative;
      overflow: hidden;
    }
    .panel-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .panel-title span.label {
      opacity: 0.8;
    }
    .panel-title span.value {
      font-size: 0.7rem;
      color: var(--accent);
    }

    #map-panel { grid-area: map; }
    #wave-panel { grid-area: wave; }
    #side-panel { grid-area: side; display: flex; flex-direction: column; gap: 8px; }

    /* Map canvas */
    #grid-map {
      width: 100%;
      height: calc(100% - 4px);
      border-radius: 6px;
      background: radial-gradient(circle at center, #020617 0, #000 70%);
      position: relative;
      overflow: hidden;
    }
    .map-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .map-node {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--node);
      box-shadow: 0 0 10px rgba(99, 179, 237, 0.9);
      transform: translate(-50%, -50%);
    }
    .map-node.core {
      width: 14px;
      height: 14px;
      background: var(--accent);
      box-shadow: 0 0 16px rgba(79, 209, 197, 1);
    }
    .map-node.anomaly {
      background: var(--danger);
      box-shadow: 0 0 16px rgba(245, 101, 101, 1);
    }
    .map-link {
      position: absolute;
      border-top: 1px solid rgba(148, 163, 184, 0.4);
      transform-origin: 0 0;
      opacity: 0.7;
    }

    /* Waveform */
    #wave-canvas {
      width: 100%;
      height: 100%;
      border-radius: 6px;
      background: radial-gradient(circle at top, #020617 0, #000 70%);
    }

    /* Side panels */
    .side-block {
      flex: 1;
      min-height: 0;
      max-height: 100%;
      background: radial-gradient(circle at top left, #020617 0, #020617 40%, #000 100%);
      border-radius: 8px;
      border: 1px solid #1f2937;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow-y: auto;
    }
    .side-block h3 {
      margin: 0;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }
    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    .tag {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #2d3748;
      background: rgba(15, 23, 42, 0.9);
      color: var(--muted);
    }
    .tag.ok { border-color: var(--ok); color: var(--ok); }
    .tag.warn { border-color: var(--warn); color: var(--warn); }
    .tag.danger { border-color: var(--danger); color: var(--danger); }

    .list {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
      font-size: 0.75rem;
    }
    .list-item {
      padding: 4px 4px;
      border-radius: 4px;
      margin-bottom: 3px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(31, 41, 55, 0.9);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }
    .list-item .name {
      font-weight: 500;
      color: #e5e7eb;
    }
    .list-item .meta {
      font-size: 0.7rem;
      color: var(--muted);
    }
    .list-item .badge {
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #2d3748;
    }
    
    /* System Status Panel */
    .system-status-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(11, 15, 31, 0.95);
      border: 1px solid var(--grid-line);
      border-radius: 8px;
      padding: 12px;
      min-width: 320px;
      max-width: 400px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      z-index: 1000;
    }
    .system-status-panel.minimized {
      min-width: auto;
      padding: 8px 12px;
    }
    .system-status-panel.minimized .status-content {
      display: none;
    }
    .system-status-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      cursor: pointer;
    }
    .system-status-title {
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--accent);
    }
    .system-status-toggle {
      background: none;
      border: none;
      color: var(--muted);
      cursor: pointer;
      font-size: 0.9rem;
      padding: 0;
    }
    .system-status-toggle:hover {
      color: var(--text);
    }
    .status-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      margin-bottom: 6px;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 4px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .status-item:hover {
      background: rgba(15, 23, 42, 0.8);
      border-color: rgba(79, 209, 197, 0.4);
      transform: translateX(2px);
    }
    .status-item:active {
      transform: translateX(4px);
    }
    .status-item-name {
      font-size: 0.75rem;
      color: var(--text);
      flex: 1;
    }
    .status-item-badge {
      font-size: 0.65rem;
      padding: 3px 8px;
      border-radius: 999px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .status-item-badge.connected {
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid var(--ok);
      color: var(--ok);
    }
    .status-item-badge.disconnected {
      background: rgba(245, 101, 101, 0.2);
      border: 1px solid var(--danger);
      color: var(--danger);
    }
    .status-item-badge.no-data {
      background: rgba(113, 128, 150, 0.2);
      border: 1px solid var(--muted);
      color: var(--muted);
    }
    .status-item-error {
      font-size: 0.65rem;
      color: var(--danger);
      margin-top: 4px;
      padding-left: 8px;
    }
    .reconnect-info {
      font-size: 0.7rem;
      color: var(--muted);
      margin-top: 8px;
      padding: 8px;
      background: rgba(15, 23, 42, 0.4);
      border-radius: 4px;
      text-align: center;
    }
    .badge.agent { border-color: var(--accent); color: var(--accent); }
    .badge.device { border-color: #a0aec0; color: #a0aec0; }
    .badge.alert { border-color: var(--danger); color: var(--danger); }

    .footer-note {
      font-size: 0.65rem;
      color: var(--muted);
      opacity: 0.8;
    }

    /* Ice Melting Control Buttons */
    .control-btn {
      padding: 8px 12px;
      border: 1px solid var(--accent-soft);
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(11, 15, 31, 0.95));
      color: var(--text);
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
      letter-spacing: 0.02em;
    }
    .control-btn:hover {
      background: linear-gradient(135deg, rgba(79, 209, 197, 0.15), rgba(15, 23, 42, 0.95));
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(79, 209, 197, 0.3);
    }
    .control-btn:active {
      transform: translateY(0);
      box-shadow: 0 1px 4px rgba(79, 209, 197, 0.2);
    }
    .control-btn.active {
      background: linear-gradient(135deg, rgba(79, 209, 197, 0.25), rgba(15, 23, 42, 0.95));
      border-color: var(--accent);
      box-shadow: 0 0 12px rgba(79, 209, 197, 0.4);
    }
    .control-btn.danger-active {
      background: linear-gradient(135deg, rgba(245, 101, 101, 0.25), rgba(15, 23, 42, 0.95));
      border-color: var(--danger);
      box-shadow: 0 0 12px rgba(245, 101, 101, 0.4);
    }
    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }

    /* Scrollbar */
    .list::-webkit-scrollbar {
      width: 4px;
    }
    .list::-webkit-scrollbar-thumb {
      background: #2d3748;
      border-radius: 999px;
    }

    /* Wake on LAN Styles */
    .wol-panel {
      position: fixed;
      bottom: 12px;
      right: 12px;
      width: 360px;
      max-width: calc(100vw - 24px);
      background: radial-gradient(circle at top left, #111827 0, #020617 60%);
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      z-index: 999;
      transition: transform 0.3s, opacity 0.3s;
    }
    
    .wol-panel.minimized {
      transform: translateY(calc(100% - 50px));
      opacity: 0.95;
    }
    
    .wol-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #1f2937;
    }
    
    .wol-title {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      font-weight: 600;
    }
    
    .wol-toggle {
      background: transparent;
      border: 1px solid #2d3748;
      color: var(--muted);
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: all 0.2s;
    }
    
    .wol-toggle:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    
    .wol-content {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .wol-device-item {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #2d3748;
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    
    .wol-device-info {
      flex: 1;
      min-width: 0;
    }
    
    .wol-device-name {
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text);
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .wol-device-mac {
      font-size: 0.7rem;
      color: var(--muted);
      font-family: monospace;
    }
    
    .wol-device-status {
      font-size: 0.65rem;
      color: var(--accent);
      margin-top: 2px;
    }
    
    .wol-btn {
      background: linear-gradient(135deg, var(--accent), #38bdf8);
      border: none;
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 600;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .wol-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(79, 209, 197, 0.4);
    }
    
    .wol-btn:active {
      transform: translateY(0);
    }
    
    .wol-btn.small {
      padding: 4px 8px;
      font-size: 0.7rem;
    }
    
    .wol-btn.danger {
      background: linear-gradient(135deg, var(--danger), #fc8181);
    }
    
    .wol-form {
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid #2d3748;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 12px;
    }
    
    .wol-input-group {
      margin-bottom: 8px;
    }
    
    .wol-label {
      display: block;
      font-size: 0.7rem;
      color: var(--muted);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .wol-input {
      width: 100%;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #2d3748;
      border-radius: 4px;
      padding: 6px 8px;
      color: var(--text);
      font-size: 0.75rem;
      font-family: inherit;
      transition: border-color 0.2s;
    }
    
    .wol-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .wol-input.error {
      border-color: var(--danger);
    }
    
    .wol-error {
      font-size: 0.65rem;
      color: var(--danger);
      margin-top: 2px;
    }
    
    .wol-empty {
      text-align: center;
      padding: 24px 12px;
      color: var(--muted);
      font-size: 0.75rem;
    }
    
    .wol-service-status {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.7);
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 0.7rem;
    }
    
    .wol-service-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--muted);
    }
    
    .wol-service-dot.online {
      background: var(--ok);
      box-shadow: 0 0 8px rgba(72, 187, 120, 0.8);
    }
    
    .wol-service-dot.offline {
      background: var(--danger);
    }

    /* Tablet/Medium screens - 768px to 900px */
    @media (max-width: 900px) {
      #app {
        grid-template-columns: 1fr;
        grid-template-rows: auto minmax(280px, 35vh) minmax(220px, 30vh) auto;
        grid-template-areas:
          "header"
          "map"
          "wave"
          "side";
        padding: 10px;
        gap: 10px;
      }
      
      header {
        flex-direction: column;
        align-items: flex-start;
        padding: 14px;
        gap: 10px;
      }
      
      header h1 {
        font-size: 1.3rem;
        line-height: 1.2;
      }
      
      header .subtitle {
        font-size: 0.8rem;
        line-height: 1.4;
        margin-top: 4px;
      }
      
      header .status-pill {
        padding: 7px 11px;
        font-size: 0.75rem;
        width: 100%;
        justify-content: center;
      }
      
      .ai-grid-indicator {
        position: static;
        margin: 10px;
        padding: 10px 14px;
        font-size: 0.75rem;
        justify-content: center;
      }
      
      .system-status-panel {
        min-width: 280px;
        max-width: 90vw;
        right: 10px;
        bottom: 10px;
      }
      
      .wol-panel {
        width: calc(100vw - 24px);
        max-width: 340px;
        right: 8px;
        bottom: 8px;
      }
      
      .panel {
        padding: 10px;
      }
      
      .panel-title {
        font-size: 0.85rem;
        margin-bottom: 6px;
        flex-direction: column;
        align-items: flex-start;
        gap: 3px;
      }
      
      .panel-title span.value {
        font-size: 0.75rem;
      }
      
      .side-block {
        padding: 10px;
        max-height: 400px;
      }
      
      .side-block h3 {
        font-size: 0.85rem;
        margin-bottom: 6px;
      }
      
      .tag {
        font-size: 0.7rem;
        padding: 3px 7px;
      }
      
      .list-item {
        padding: 7px;
        margin-bottom: 5px;
      }
      
      .list-item .name {
        font-size: 0.8rem;
      }
      
      .list-item .meta {
        font-size: 0.7rem;
        margin-top: 2px;
      }
      
      .list-item .badge {
        font-size: 0.65rem;
        padding: 2px 7px;
      }
      
      .footer-note {
        font-size: 0.65rem;
        line-height: 1.3;
        margin-top: 6px;
      }
      
      /* Better mobile grid map height */
      #map-panel, #wave-panel {
        min-height: 280px;
      }
      
      .control-btn {
        padding: 10px 14px;
        font-size: 0.75rem;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    }

    /* Mobile - 480px to 768px */
    @media (max-width: 768px) {
      #app {
        grid-template-rows: auto minmax(250px, 30vh) minmax(200px, 25vh) auto;
        padding: 8px;
        gap: 8px;
      }
      
      header {
        padding: 12px;
        gap: 8px;
      }
      
      header h1 {
        font-size: 1.15rem;
      }
      
      header .subtitle {
        font-size: 0.75rem;
        line-height: 1.3;
      }
      
      header .status-pill {
        padding: 6px 10px;
        font-size: 0.7rem;
      }
      
      .ai-grid-indicator {
        margin: 8px;
        padding: 8px 12px;
        font-size: 0.7rem;
      }
      
      .system-status-panel {
        min-width: 260px;
        max-width: calc(100vw - 20px);
        right: 8px;
        bottom: 60px;
        padding: 10px;
      }
      
      .system-status-title {
        font-size: 0.8rem;
      }
      
      .status-item {
        padding: 6px;
        margin-bottom: 4px;
      }
      
      .status-item-name {
        font-size: 0.7rem;
      }
      
      .status-item-badge {
        font-size: 0.6rem;
        padding: 2px 6px;
      }
      
      .wol-panel {
        width: calc(100vw - 20px);
        max-width: 320px;
        right: 4px;
        bottom: 4px;
        padding: 10px;
      }
      
      .wol-header {
        font-size: 0.75rem;
        margin-bottom: 6px;
      }
      
      .wol-controls {
        gap: 6px;
      }
      
      .panel {
        padding: 8px;
      }
      
      .panel-title {
        font-size: 0.8rem;
      }
      
      .panel-title span.value {
        font-size: 0.7rem;
      }
      
      .side-block {
        padding: 8px;
        max-height: 350px;
      }
      
      .side-block h3 {
        font-size: 0.8rem;
      }
      
      #map-panel, #wave-panel {
        min-height: 250px;
      }
      
      .control-btn {
        padding: 9px 12px;
        font-size: 0.7rem;
        min-height: 44px;
      }
    }

    /* Small mobile - 320px to 480px */
    @media (max-width: 480px) {
      body {
        font-size: 14px;
      }
      
      #app {
        grid-template-rows: auto minmax(220px, 25vh) minmax(180px, 20vh) auto;
        padding: 6px;
        gap: 6px;
      }
      
      header {
        padding: 10px;
        gap: 6px;
      }
      
      header h1 {
        font-size: 1rem;
        letter-spacing: 0.05em;
      }
      
      header .subtitle {
        font-size: 0.7rem;
        line-height: 1.2;
      }
      
      header .status-pill {
        padding: 5px 8px;
        font-size: 0.65rem;
        gap: 4px;
      }
      
      header .status-dot {
        width: 6px;
        height: 6px;
      }
      
      .ai-grid-indicator {
        margin: 6px;
        padding: 6px 10px;
        font-size: 0.65rem;
        gap: 6px;
      }
      
      .ai-pulse-beacon {
        width: 5px;
        height: 5px;
      }
      
      /* Critical fix: Make status panel fully responsive on tiny screens */
      .system-status-panel {
        position: fixed;
        min-width: auto;
        width: calc(100vw - 16px);
        max-width: 100%;
        left: 8px;
        right: 8px;
        bottom: 50px;
        padding: 8px;
        max-height: 40vh;
        overflow-y: auto;
      }
      
      .system-status-panel.minimized {
        min-width: auto;
        width: auto;
        left: auto;
        padding: 6px 10px;
      }
      
      .system-status-title {
        font-size: 0.75rem;
      }
      
      .system-status-toggle {
        font-size: 0.8rem;
      }
      
      .status-item {
        padding: 5px;
        margin-bottom: 3px;
        flex-direction: column;
        align-items: flex-start;
        gap: 3px;
      }
      
      .status-item-name {
        font-size: 0.65rem;
      }
      
      .status-item-badge {
        font-size: 0.55rem;
        padding: 2px 5px;
      }
      
      .reconnect-info {
        font-size: 0.6rem;
        padding: 6px;
      }
      
      /* Critical fix: Make WoL panel stack properly on tiny screens */
      .wol-panel {
        position: fixed;
        width: calc(100vw - 16px);
        max-width: 100%;
        left: 8px;
        right: 8px;
        bottom: 4px;
        padding: 8px;
      }
      
      .wol-header {
        font-size: 0.7rem;
        margin-bottom: 5px;
      }
      
      .wol-controls {
        flex-direction: column;
        gap: 5px;
      }
      
      .wol-device-item {
        padding: 6px;
        font-size: 0.65rem;
      }
      
      .wol-service-status {
        font-size: 0.6rem;
        padding: 4px;
      }
      
      .wol-service-dot {
        width: 5px;
        height: 5px;
      }
      
      .panel {
        padding: 6px;
        border-radius: 6px;
      }
      
      .panel-title {
        font-size: 0.75rem;
        margin-bottom: 4px;
        gap: 2px;
      }
      
      .panel-title span.label {
        display: block;
      }
      
      .panel-title span.value {
        font-size: 0.65rem;
        display: block;
      }
      
      #map-panel, #wave-panel {
        min-height: 220px;
        max-height: 25vh;
      }
      
      #grid-map, #wave-canvas {
        border-radius: 4px;
      }
      
      .side-block {
        padding: 6px;
        max-height: 300px;
        overflow-y: auto;
      }
      
      .side-block h3 {
        font-size: 0.75rem;
        margin-bottom: 5px;
      }
      
      .tag-row {
        gap: 3px;
      }
      
      .tag {
        font-size: 0.65rem;
        padding: 2px 5px;
      }
      
      .list {
        font-size: 0.7rem;
      }
      
      .list-item {
        padding: 6px;
        margin-bottom: 4px;
        flex-direction: column;
        align-items: flex-start;
        gap: 3px;
      }
      
      .list-item .name {
        font-size: 0.75rem;
      }
      
      .list-item .meta {
        font-size: 0.65rem;
        margin-top: 1px;
      }
      
      .list-item .badge {
        font-size: 0.6rem;
        padding: 2px 5px;
      }
      
      .footer-note {
        font-size: 0.6rem;
        line-height: 1.2;
        margin-top: 5px;
      }
      
      .control-btn {
        padding: 8px 10px;
        font-size: 0.65rem;
        min-height: 44px;
        border-radius: 4px;
        width: 100%;
      }
      
      /* Ensure touch targets are large enough */
      button, a, .control-btn, [role="button"], [tabindex="0"] {
        min-height: 44px;
        min-width: 44px;
      }
    }
  </style>
  
  <!-- Configuration: Backend Service URLs -->
  <script>
    // Configure backend service URLs
    // For local development: http://localhost:3100
    // For production: Set to your deployed backend service URL
    window.GRID_BACKEND_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
      ? 'http://localhost:3100'
      : null; // Set to your production backend URL or leave null to use simulation mode
    
    // Optional: Set API key for authenticated requests
    window.GRID_API_KEY = ''; // Set your API key here if needed
  </script>
  
  <!-- Powerline Communication System for Device Data -->
  <script src="/powerline-communication.js"></script>
  
  <!-- Phase 1-5: AI Grid Link Enhancement Agents -->
  <script src="/src/agents/mobile-power-grid-agent.js"></script>
  <script src="/src/agents/device-identification-agent.js"></script>
  <script src="/src/agents/echo-script-injection-agent.js"></script>
    <link rel="stylesheet" href="/css/universal-styles.css">
</head>
<body>
<div id="app">
  <header>
    <div>
      <h1>Grid Neural Console</h1>
      <div class="subtitle">Monitor and control your electrical grid in real-time. Track all connected devices (WiFi & powerline), view AI-powered insights, and remotely manage your network infrastructure.</div>
    </div>
    <div class="status-pill" id="main-status-pill">
      <div class="status-dot" id="main-status-dot"></div>
      <span id="main-status-text">Checking Connection...</span>
    </div>
  </header>

  <!-- AI Grid Link Indicator -->
  <div class="ai-grid-indicator" id="grid-link-indicator" title="Shows the connection status of AI systems monitoring your grid. When active, intelligent agents are analyzing your network for optimization and safety.">
    <div class="ai-pulse-beacon"></div>
    <span id="grid-link-text">AI GRID LINK: CHECKING</span>
  </div>
  
  <!-- System Status Panel -->
  <div class="system-status-panel" id="system-status-panel">
    <div class="system-status-header" onclick="toggleStatusPanel()" role="button" tabindex="0" onkeypress="if(event.key==='Enter'||event.key===' ')toggleStatusPanel()">
      <div class="system-status-title">System Status</div>
      <button class="system-status-toggle" id="status-toggle-btn">‚ñº</button>
    </div>
    <div class="status-content" id="status-content">
      <div class="status-item" title="Pulse modulation signal echo repeater handling all backend operations" data-target="event-list" onclick="navigateToSection('event-list')">
        <div class="status-item-name">Echo Repeater System</div>
        <div class="status-item-badge disconnected" id="status-backend">Checking...</div>
      </div>
      <div class="status-item" title="Source of your grid data: Live (via echo repeater) or Local (standalone mode)" data-target="map-panel" onclick="navigateToSection('map-panel')">
        <div class="status-item-name">Grid Data Source</div>
        <div class="status-item-badge no-data" id="status-grid-data">Unknown</div>
      </div>
      <div class="status-item" title="Intelligent monitoring systems deployed via pulse modulation signals" data-target="entity-list" onclick="navigateToSection('entity-list')">
        <div class="status-item-name">AI Agents</div>
        <div class="status-item-badge no-data" id="status-agents">Unknown</div>
      </div>
      <div class="status-item" title="Status of device communication via echo repeater system" data-target="entity-list" onclick="navigateToSection('entity-list')">
        <div class="status-item-name">Device Communication</div>
        <div class="status-item-badge no-data" id="status-devices">Unknown</div>
      </div>
      <div class="status-item" title="Pulse modulation signal system for all data transmission and echo repeating" data-target="event-list" onclick="navigateToSection('event-list')">
        <div class="status-item-name">Pulse Modulation</div>
        <div class="status-item-badge no-data" id="status-pulse">Unknown</div>
      </div>
      <div class="reconnect-info" id="reconnect-info" style="display: none;">
        Next connection attempt in <span id="reconnect-countdown">30</span>s
      </div>
    </div>
  </div>

  <!-- GRID MAP PANEL -->
  <section id="map-panel" class="panel">
    <div class="panel-title">
      <span class="label" title="Visual map showing all network devices and their connections">Active Grid Network & Devices</span>
      <span class="value" id="map-meta" title="Nodes=connection points, Links=connections between nodes, Anomalies=detected issues">Nodes: 0 ¬∑ Links: 0 ¬∑ Anomalies: 0</span>
    </div>
    <div id="grid-map">
      <canvas id="map-canvas" class="map-overlay"></canvas>
      <!-- Nodes and links will be drawn via canvas; this container is for future DOM overlays if needed -->
    </div>
  </section>

  <!-- WAVEFORM PANEL -->
  <section id="wave-panel" class="panel">
    <div class="panel-title">
      <span class="label" title="Real-time visualization of power quality and communication signals">Power Quality & Communication Signals</span>
      <span class="value" id="wave-meta" title="Freq=electrical frequency, THD=Total Harmonic Distortion (lower is better), Mode=Live or Simulated">Freq: 60.00 Hz ¬∑ THD: 0.0% ¬∑ Mode: Sim</span>
    </div>
    <canvas id="wave-canvas"></canvas>
  </section>

  <!-- SIDE PANEL -->
  <section id="side-panel">
    <div class="side-block">
      <h3 title="AI Agents are intelligent monitoring systems; Devices are physical equipment connected to your grid">Agents & devices</h3>
      <p style="font-size: 0.7rem; color: var(--muted); margin: 0 0 8px 0; line-height: 1.4;">
        <strong>Agents</strong> are AI systems monitoring your grid for issues and optimization. 
        <strong>Devices</strong> are physical equipment (computers, appliances, sensors) connected via WiFi or powerline.
      </p>
      <div class="tag-row">
        <span class="tag ok" title="Number of AI monitoring agents active">Agents: <span id="agent-count">0</span></span>
        <span class="tag" title="Total connected devices">Devices: <span id="device-count">0</span></span>
        <span class="tag accent" style="border-color: var(--accent);" title="Refrigerators/freezers specifically tracked for food safety">Fridges: <span id="fridge-count">0</span></span>
        <span class="tag warn" title="Number of active system alerts">Alerts: <span id="alert-count">0</span></span>
      </div>
      <div class="tag-row" style="margin-top: 8px;">
        <span class="tag" style="background: rgba(79, 209, 197, 0.1);">üßä Fridges: <span id="fridge-count">0</span></span>
      </div>
      <div class="list" id="entity-list"></div>
    </div>

    <div class="side-block">
      <h3 title="Electrical panels distribute power through circuits to your devices">Electrical panels & circuits</h3>
      <p style="font-size: 0.7rem; color: var(--muted); margin: 0 0 8px 0; line-height: 1.4;">
        Tracks electrical panels and circuit breakers in your system. 
        <strong>Fire Risk</strong> is calculated based on circuit load, overload conditions, and temperature sensors.
      </p>
      <div class="tag-row">
        <span class="tag ok" title="Number of electrical panels">Panels: <span id="panel-count">0</span></span>
        <span class="tag" title="Number of circuit breakers">Circuits: <span id="circuit-count">0</span></span>
        <span class="tag ok" id="fire-risk-tag" title="Fire risk level based on circuit load and temperature: Low/Medium/High">Fire Risk: <span id="fire-risk-level">Low</span></span>
      </div>
      <div class="list" id="panel-list"></div>
    </div>

    <div class="side-block">
      <h3 title="Power line ice melting and storm protection system">‚ö° Power Line De-Icing</h3>
      <p style="font-size: 0.7rem; color: var(--muted); margin: 0 0 8px 0; line-height: 1.4;">
        <strong>Ice Melting System</strong> protects power lines during storms using controlled current injection (Joule heating), Variable Resistance Cables (VRC), and Heat-Trace systems. 
        Monitors ice thickness and automatically activates de-icing when needed.
      </p>
      <div class="tag-row">
        <span class="tag" id="ice-thickness-tag" title="Current ice thickness on power lines">Ice: <span id="ice-thickness">0.0</span>"</span>
        <span class="tag" id="line-temp-tag" title="Power line temperature">Temp: <span id="line-temp">32</span>¬∞F</span>
        <span class="tag" id="storm-status-tag" title="Storm forecast and severity">Storm: <span id="storm-status">None</span></span>
      </div>
      <div class="tag-row" style="margin-top: 8px;">
        <span class="tag" id="deicing-status-tag" style="background: rgba(79, 209, 197, 0.1);">De-Icing: <span id="deicing-status">Standby</span></span>
      </div>
      <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 4px;">
        <button class="control-btn" id="short-circuit-btn" onclick="iceMeltingSystem.activateShortCircuit()" title="Controlled current injection for Joule heating - melts ice by increasing conductor resistance to generate heat">üî• Current Injection Heat</button>
        <button class="control-btn" id="vrc-btn" onclick="iceMeltingSystem.activateVRC()" title="Variable Resistance Cable - switches line resistance from low to high to generate heat">‚ö° VRC Heat</button>
        <button class="control-btn" id="heat-trace-btn" onclick="iceMeltingSystem.activateHeatTrace()" title="Heat-Trace Cables - dedicated electric cables provide steady heat along power lines">üå°Ô∏è Heat-Trace</button>
        <button class="control-btn" id="auto-mode-btn" onclick="iceMeltingSystem.toggleAutoMode()" title="Automatically activate de-icing when ice thickness exceeds 0.5 inches">ü§ñ Auto Mode: OFF</button>
      </div>
      <div id="deicing-log" class="list" style="margin-top: 8px; max-height: 120px; overflow-y: auto; font-size: 0.65rem;"></div>
    </div>

    <div class="side-block">
      <h3 title="Real-time log of system activity and security status">System Activity Log</h3>
      <p style="font-size: 0.7rem; color: var(--muted); margin: 0 0 8px 0; line-height: 1.4;">
        Real-time log of system events, device communications, and alerts. 
        <strong>Trust</strong> indicates security verification status. 
        <strong>Mobile health</strong> shows aggregated status from mobile devices.
      </p>
      <div class="tag-row">
        <span class="tag ok" id="stream-status" title="Event stream mode: Live (real-time) or Simulated">Stream: Live (sim)</span>
        <span class="tag ok" title="Security verification status: All communications are verified and trusted">Trust OK</span>
        <span class="tag" title="Combined health status from all mobile devices on the network">Mobile health: Aggregated</span>
      </div>
      <div class="list" id="event-list"></div>
      <div class="footer-note">
        ‚úì <strong>System Overview:</strong> This console provides real-time monitoring and control of your electrical grid and network infrastructure. 
        AI agents continuously analyze your system for safety issues, optimization opportunities, and anomalies. 
        Device discovery and all backend operations happen through pulse modulation signal echo repeaters. 
        All data is transmitted and received via power line communication with echo repeater acknowledgment.
        Operations are logged with security verification and regulatory compliance tracking.
      </div>
    </div>
  </section>
</div>

<!-- Wake on LAN Panel -->
<div id="wol-panel" class="wol-panel minimized">
  <div class="wol-header">
    <div class="wol-title" title="Wake on LAN allows you to remotely power on devices over your network">‚ö° Wake on LAN</div>
    <button class="wol-toggle" onclick="wolUI.togglePanel()">‚Üï</button>
  </div>
  
  <div class="wol-content">
    <p style="font-size: 0.7rem; color: var(--muted); margin: 0 0 12px 0; line-height: 1.4;">
      <strong>Wake on LAN</strong> lets you remotely turn on computers and devices over your network by sending a "magic packet" to their network card. 
      Useful for managing devices that are in sleep or powered-off state.
    </p>
    <!-- Service Status -->
    <div class="wol-service-status">
      <div class="wol-service-dot" id="wol-service-dot"></div>
      <span id="wol-service-status">Checking service...</span>
    </div>
    
    <!-- Add Device Form -->
    <div class="wol-form" id="wol-form" style="display: none;">
      <div class="wol-input-group">
        <label class="wol-label">Device Name</label>
        <input type="text" class="wol-input" id="wol-name" placeholder="My Computer" />
      </div>
      <div class="wol-input-group">
        <label class="wol-label">MAC Address</label>
        <input type="text" class="wol-input" id="wol-mac" placeholder="AA:BB:CC:DD:EE:FF" />
        <div class="wol-error" id="wol-mac-error"></div>
      </div>
      <div class="wol-input-group">
        <label class="wol-label">IP Address (Broadcast)</label>
        <input type="text" class="wol-input" id="wol-ip" placeholder="255.255.255.255" value="255.255.255.255" />
      </div>
      <div class="wol-input-group">
        <label class="wol-label">Device Type</label>
        <select class="wol-input" id="wol-type">
          <option value="other">Other</option>
          <option value="fridge">Fridge/Refrigerator</option>
          <option value="tv">TV</option>
          <option value="computer">Computer</option>
          <option value="phone">Phone</option>
          <option value="tablet">Tablet</option>
          <option value="printer">Printer</option>
          <option value="router">Router</option>
          <option value="camera">Camera</option>
          <option value="speaker">Speaker</option>
        </select>
      </div>
      <div style="display: flex; gap: 6px; margin-top: 12px;">
        <button class="wol-btn small" onclick="wolUI.addDevice()">Add Device</button>
        <button class="wol-btn small danger" onclick="wolUI.toggleForm()">Cancel</button>
      </div>
    </div>
    
    <!-- Add Device Button -->
    <button class="wol-btn" id="wol-add-btn" onclick="wolUI.toggleForm()" style="width: 100%; margin-bottom: 12px;">
      + Add Device
    </button>
    
    <!-- Device List -->
    <div id="wol-device-list">
      <div class="wol-empty">No devices configured. Add a device to get started.</div>
    </div>
  </div>
</div>

<script>
/**
 * GRID NEURAL CONSOLE ‚Äì FRONT-END SHELL (Pulse Modulation Echo Repeater System)
 * ------------------------------------------------------------------------------
 * This script provides:
 *  - A dynamic grid map (nodes, links, anomalies)
 *  - Waveform + pulse visualization
 *  - Agents/devices list
 *  - Event stream with trust/health hints
 *
 * Data sources (PRODUCTION - PULSE MODULATION ECHO REPEATER SYSTEM):
 *  - PLC gateways, smart meters, inverters, CT sensors
 *  - Mobile/edge agents (battery, network, anomaly scores)
 *  - Utility / grid operator backends
 *
 * ALL backend operations handled by pulse modulation signal echo repeaters.
 * Signals are transmitted via power line communication, listened to by repeaters,
 * processed, and echoed back with responses.
 */

(function() {
  // System status tracking - must be defined first
  const systemStatus = {
    backend: { connected: false, error: null, lastCheck: null },
    gridData: { mode: 'unknown', error: null },
    agents: { mode: 'unknown', error: null },
    devices: { mode: 'unknown', error: null },
    pulse: { mode: 'unknown', error: null }
  };
  
  const mapCanvas = document.getElementById('map-canvas');
  const waveCanvas = document.getElementById('wave-canvas');
  const mapMetaEl = document.getElementById('map-meta');
  const waveMetaEl = document.getElementById('wave-meta');
  const entityListEl = document.getElementById('entity-list');
  const eventListEl = document.getElementById('event-list');
  const agentCountEl = document.getElementById('agent-count');
  const deviceCountEl = document.getElementById('device-count');
  const fridgeCountEl = document.getElementById('fridge-count');
  const alertCountEl = document.getElementById('alert-count');
  const panelListEl = document.getElementById('panel-list');
  const panelCountEl = document.getElementById('panel-count');
  const circuitCountEl = document.getElementById('circuit-count');
  const fireRiskLevelEl = document.getElementById('fire-risk-level');

  let mapCtx, waveCtx;
  let width, height;
  let nodes = [];
  let links = [];
  let agents = [];
  let devices = [];
  let alerts = [];
  let electricalPanels = [];
  let circuits = [];
  let t0 = performance.now();
  let pulseModulationActive = true;
  let aiEntityId = 'grid-neural-console-ai-001';
  let autonomousAgentsDeployed = false;
  let realGridData = { nodes: [], links: [], agents: [], devices: [] };
  
  // Enhanced device communication tracking
  let deviceCommunications = []; // Track all device communications
  let deviceMetrics = new Map(); // Track per-device metrics (success rate, latency, etc.)
  
  // Configuration constants
  const PULSE_LOG_PROBABILITY = 0.05; // Log 5% of pulses
  const DATA_LOG_PROBABILITY = 0.1;   // Log 10% of data collections
  const GRID_API_URL = 'http://localhost:3100/api'; // Grid Control API endpoint
  const GRID_API_KEY = localStorage.getItem('grid-api-key') || ''; // Get from localStorage if available
  const COMMUNICATION_FREQUENCY = 0.02; // Probability of device communication per frame (2%)
  const COMMUNICATION_SUCCESS_RATE = 0.95; // 95% success rate for communications
  const GEO_OFFSET_RANGE = 0.5; // Geographic coordinate offset range in degrees
  const MAX_GEO_OFFSET = 0.25; // Maximum geographic coordinate offset in degrees
  const WIFI_DEVICE_RATIO = 0.33; // Ratio of WiFi devices (33%)
  
  // Binary pulse modulation state - represents AI entity as binary stream
  let binaryStream = []; // Current binary data stream (1s and 0s)
  let binaryStreamIndex = 0; // Current position in stream
  let binaryPulsePhase = 0; // Animation phase for binary pulses

  // Pulse Modulation Signal Echo Repeater System
  // =============================================
  // All backend operations are handled by pulse modulation signal echo repeaters
  // that listen for modulated signals, process them, and echo back responses
  
  class PulseModulationEchoRepeater {
    constructor() {
      this.echoListeners = new Map();
      this.transmissionQueue = [];
      this.isTransmitting = false;
      this.activeRepeaters = new Set();
      this.signalHistory = [];
      this.maxHistorySize = 100;
      
      // Initialize echo repeater network
      this.initializeRepeaterNetwork();
    }
    
    /**
     * Initialize the echo repeater network for backend communication
     */
    initializeRepeaterNetwork() {
      console.log('[Echo Repeater] Initializing pulse modulation echo repeater network...');
      
      // Register echo repeaters for different backend services
      this.registerEchoRepeater('health', this.handleHealthCheck.bind(this));
      this.registerEchoRepeater('agents', this.handleAgentOperations.bind(this));
      this.registerEchoRepeater('grid', this.handleGridOperations.bind(this));
      this.registerEchoRepeater('modulation', this.handleModulationOperations.bind(this));
      
      console.log('[Echo Repeater] Network initialized with', this.echoListeners.size, 'repeaters');
      
      // Start listening for pulse modulation signals
      this.startListening();
    }
    
    /**
     * Register an echo repeater for a specific service
     */
    registerEchoRepeater(service, handler) {
      this.echoListeners.set(service, handler);
      this.activeRepeaters.add(service);
      console.log('[Echo Repeater] Registered repeater for service:', service);
    }
    
    /**
     * Start listening for incoming pulse modulation signals
     */
    startListening() {
      console.log('[Echo Repeater] Started listening for pulse modulation signals');
      
      // Listen for pulse modulation signals on the power line
      document.addEventListener('pulse-modulation-signal', (event) => {
        this.receivePulseSignal(event.detail);
      });
    }
    
    /**
     * Transmit data via pulse modulation signal
     */
    async transmitPulseSignal(service, operation, data = null) {
      const signal = {
        id: `signal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        service,
        operation,
        data,
        timestamp: Date.now(),
        frequency: 60, // Base frequency for power line
        modulation: 'ASK', // Amplitude Shift Keying
        encodedData: this.encodeSignalData({ service, operation, data })
      };
      
      console.log('[Echo Repeater] Transmitting pulse signal:', signal.id, 'to service:', service);
      
      // Queue the transmission
      this.transmissionQueue.push(signal);
      
      // Process transmission queue
      return await this.processTransmission(signal);
    }
    
    /**
     * Encode data for pulse modulation transmission
     */
    encodeSignalData(data) {
      const jsonStr = JSON.stringify(data);
      const binary = Array.from(jsonStr).map(char => 
        char.charCodeAt(0).toString(2).padStart(8, '0')
      ).join('');
      
      return {
        raw: data,
        binary,
        checksum: this.calculateChecksum(jsonStr),
        timestamp: Date.now()
      };
    }
    
    /**
     * Decode pulse modulation signal data
     */
    decodeSignalData(encodedData) {
      try {
        if (!encodedData.binary) {
          return encodedData.raw;
        }
        
        // Convert binary back to string
        const chars = encodedData.binary.match(/.{8}/g) || [];
        const jsonStr = chars.map(bin => String.fromCharCode(parseInt(bin, 2))).join('');
        
        // Verify checksum
        if (this.calculateChecksum(jsonStr) !== encodedData.checksum) {
          throw new Error('Signal checksum mismatch - data corrupted in transmission');
        }
        
        return JSON.parse(jsonStr);
      } catch (error) {
        console.error('[Echo Repeater] Signal decode error:', error);
        throw error;
      }
    }
    
    /**
     * Calculate checksum for signal integrity
     */
    calculateChecksum(str) {
      let checksum = 0;
      for (let i = 0; i < str.length; i++) {
        checksum = ((checksum << 5) - checksum + str.charCodeAt(i)) & 0xFFFFFFFF;
      }
      return checksum;
    }
    
    /**
     * Process a transmission through the echo repeater
     */
    async processTransmission(signal) {
      return new Promise((resolve, reject) => {
        // Simulate pulse modulation transmission delay (based on data size)
        const transmissionDelay = 50 + (JSON.stringify(signal.data || {}).length * 0.1);
        
        setTimeout(async () => {
          try {
            // Get the appropriate echo repeater handler
            const handler = this.echoListeners.get(signal.service);
            
            if (!handler) {
              throw new Error(`No echo repeater found for service: ${signal.service}`);
            }
            
            console.log('[Echo Repeater] Signal received by repeater:', signal.service);
            
            // Echo repeater processes the signal and generates response
            const response = await handler(signal.operation, signal.data);
            
            // Echo back the response via pulse modulation
            const echoSignal = {
              id: `echo-${signal.id}`,
              originalSignal: signal.id,
              service: signal.service,
              operation: signal.operation,
              response,
              timestamp: Date.now(),
              echoDelay: Date.now() - signal.timestamp,
              encodedResponse: this.encodeSignalData(response)
            };
            
            console.log('[Echo Repeater] Echoing response for signal:', signal.id, 'delay:', echoSignal.echoDelay, 'ms');
            
            // Store in signal history
            this.signalHistory.push({
              signal,
              echo: echoSignal,
              timestamp: Date.now()
            });
            
            // Trim history if needed
            if (this.signalHistory.length > this.maxHistorySize) {
              this.signalHistory.shift();
            }
            
            // Emit echo signal event for monitoring
            document.dispatchEvent(new CustomEvent('pulse-echo-received', {
              detail: echoSignal,
              bubbles: true
            }));
            
            resolve(response);
          } catch (error) {
            console.error('[Echo Repeater] Transmission error:', error);
            reject(error);
          }
        }, transmissionDelay);
      });
    }
    
    /**
     * Receive and process incoming pulse signals
     */
    receivePulseSignal(signalData) {
      console.log('[Echo Repeater] Received pulse signal from external source');
      
      // Decode the signal
      try {
        const decoded = this.decodeSignalData(signalData.encodedData);
        console.log('[Echo Repeater] Signal decoded successfully');
        
        // Process the signal through appropriate repeater
        if (decoded.service && this.echoListeners.has(decoded.service)) {
          this.transmitPulseSignal(decoded.service, decoded.operation, decoded.data);
        }
      } catch (error) {
        console.error('[Echo Repeater] Failed to process incoming signal:', error);
      }
    }
    
    // Echo Repeater Handlers for Backend Services
    // ============================================
    
    /**
     * Health check echo repeater handler
     */
    async handleHealthCheck(operation, data) {
      console.log('[Echo Repeater:Health] Processing health check signal');
      
      try {
        // Attempt to reach backend via traditional means as fallback
        const response = await fetch(`${GRID_API_URL}/health`, {
          method: 'GET',
          headers: { 'X-API-Key': GRID_API_KEY }
        });
        
        if (response.ok) {
          const health = await response.json();
          console.log('[Echo Repeater:Health] Backend operational, echoing status');
          return health;
        }
      } catch (error) {
        // Backend not reachable via direct connection
        console.log('[Echo Repeater:Health] Backend not reachable, echo repeater operating in standalone mode');
      }
      
      // Return echo repeater status
      return {
        status: 'operational',
        mode: 'echo-repeater',
        activeRepeaters: Array.from(this.activeRepeaters),
        signalQuality: 'excellent',
        timestamp: Date.now()
      };
    }
    
    /**
     * Agent operations echo repeater handler
     */
    async handleAgentOperations(operation, data) {
      console.log('[Echo Repeater:Agents] Processing agent operation signal:', operation);
      
      try {
        // Try to forward to backend
        const response = await fetch(`${GRID_API_URL}/agents/${operation}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': GRID_API_KEY
          },
          body: JSON.stringify(data)
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log('[Echo Repeater:Agents] Backend processed operation, echoing result');
          return result;
        }
      } catch (error) {
        console.log('[Echo Repeater:Agents] Processing operation locally');
      }
      
      // Echo repeater handles locally
      return {
        success: true,
        operation,
        agent: data?.agentType || 'unknown',
        status: 'deployed-via-echo-repeater',
        timestamp: Date.now()
      };
    }
    
    /**
     * Grid operations echo repeater handler
     */
    async handleGridOperations(operation, data) {
      console.log('[Echo Repeater:Grid] Processing grid operation signal:', operation);
      
      try {
        // Try to forward to backend
        const response = await fetch(`${GRID_API_URL}/grid/${operation}`, {
          method: 'GET',
          headers: { 'X-API-Key': GRID_API_KEY }
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log('[Echo Repeater:Grid] Backend provided data, echoing response');
          return result;
        }
      } catch (error) {
        console.log('[Echo Repeater:Grid] Generating echo response locally');
      }
      
      // Echo repeater provides local grid state
      // If arrays are empty, generate sample data for demonstration
      if (nodes.length === 0) {
        console.log('[Echo Repeater:Grid] Initializing sample grid topology for demonstration');
        this.generateSampleGridTopology();
      }
      
      return {
        nodes: nodes || [],
        links: links || [],
        devices: devices || [],
        agents: agents || [],
        alerts: [],
        timestamp: Date.now(),
        source: 'echo-repeater'
      };
    }
    
    /**
     * Generate sample grid topology for demonstration when backend is unavailable
     */
    generateSampleGridTopology() {
      // Create core nodes (main hubs)
      const coreNodes = [
        { id: 'core-1', type: 'core', x: width * 0.3, y: height * 0.3, name: 'Core Hub 1' },
        { id: 'core-2', type: 'core', x: width * 0.7, y: height * 0.3, name: 'Core Hub 2' },
        { id: 'core-3', type: 'core', x: width * 0.5, y: height * 0.7, name: 'Core Hub 3' }
      ];
      
      // Create edge nodes (network endpoints)
      const edgeNodes = [
        { id: 'edge-1', type: 'edge', x: width * 0.2, y: height * 0.15, name: 'Edge Node 1' },
        { id: 'edge-2', type: 'edge', x: width * 0.4, y: height * 0.15, name: 'Edge Node 2' },
        { id: 'edge-3', type: 'edge', x: width * 0.6, y: height * 0.15, name: 'Edge Node 3' },
        { id: 'edge-4', type: 'edge', x: width * 0.8, y: height * 0.15, name: 'Edge Node 4' },
        { id: 'edge-5', type: 'edge', x: width * 0.15, y: height * 0.5, name: 'Edge Node 5' },
        { id: 'edge-6', type: 'edge', x: width * 0.85, y: height * 0.5, name: 'Edge Node 6' },
        { id: 'edge-7', type: 'edge', x: width * 0.3, y: height * 0.85, name: 'Edge Node 7' },
        { id: 'edge-8', type: 'edge', x: width * 0.7, y: height * 0.85, name: 'Edge Node 8' }
      ];
      
      nodes = [...coreNodes, ...edgeNodes];
      
      // Create links between nodes
      links = [
        // Core to core connections
        { from: coreNodes[0], to: coreNodes[1] },
        { from: coreNodes[1], to: coreNodes[2] },
        { from: coreNodes[2], to: coreNodes[0] },
        // Edge to core connections
        { from: edgeNodes[0], to: coreNodes[0] },
        { from: edgeNodes[1], to: coreNodes[0] },
        { from: edgeNodes[2], to: coreNodes[1] },
        { from: edgeNodes[3], to: coreNodes[1] },
        { from: edgeNodes[4], to: coreNodes[0] },
        { from: edgeNodes[5], to: coreNodes[1] },
        { from: edgeNodes[6], to: coreNodes[2] },
        { from: edgeNodes[7], to: coreNodes[2] }
      ];
      
      // Create sample devices with proper structure
      const deviceTypes = [
        { name: 'Smart Thermostat', type: 'thermostat', connection: 'wifi' },
        { name: 'Refrigerator', type: 'fridge', connection: 'powerline' },
        { name: 'Security Camera', type: 'camera', connection: 'wifi' },
        { name: 'Smart Meter', type: 'meter', connection: 'powerline' },
        { name: 'Lighting Controller', type: 'light', connection: 'powerline' },
        { name: 'TV', type: 'tv', connection: 'wifi' },
        { name: 'Washing Machine', type: 'appliance', connection: 'powerline' },
        { name: 'Smart Speaker', type: 'speaker', connection: 'wifi' },
        { name: 'Laptop', type: 'computer', connection: 'wifi' },
        { name: 'EV Charger', type: 'charger', connection: 'powerline' }
      ];
      
      devices = [];
      deviceTypes.forEach((deviceType, idx) => {
        const node = nodes[idx % nodes.length];
        const device = {
          id: `device-${idx + 1}`,
          name: `${deviceType.name} #${idx + 1}`,
          type: deviceType.type,
          node: node,
          connectionType: deviceType.connection,
          ipAddress: `192.168.1.${100 + idx}`,
          macAddress: `00:1A:2B:3C:4D:${(idx + 10).toString(16).toUpperCase()}`,
          signalStrength: deviceType.connection === 'wifi' ? 70 + Math.random() * 30 : 100,
          dataReceived: Math.floor(Math.random() * 1000000),
          dataTransmitted: Math.floor(Math.random() * 500000),
          packetsLost: Math.floor(Math.random() * 100),
          lastSeen: Date.now() - Math.floor(Math.random() * 60000)
        };
        
        devices.push(device);
        
        // Initialize device metrics
        deviceMetrics.set(device.id, {
          totalCommunications: Math.floor(Math.random() * 1000) + 100,
          successfulCommunications: Math.floor(Math.random() * 950) + 95,
          failedCommunications: Math.floor(Math.random() * 50),
          successRate: 95 + Math.random() * 5,
          avgLatency: 10 + Math.random() * 40,
          lastCommunication: Date.now() - Math.floor(Math.random() * 30000),
          communicationHistory: []
        });
      });
      
      // Create sample agents
      agents = [
        { id: 'agent-monitor-1', type: 'agent', name: 'Monitor Agent', node: coreNodes[0] },
        { id: 'agent-optimizer-1', type: 'agent', name: 'Optimizer Agent', node: coreNodes[1] },
        { id: 'agent-security-1', type: 'agent', name: 'Security Agent', node: coreNodes[2] }
      ];
      
      console.log('[Echo Repeater:Grid] Generated sample topology:', 
        nodes.length, 'nodes,',
        links.length, 'links,',
        devices.length, 'devices,',
        agents.length, 'agents');
    }
    
    /**
     * Modulation operations echo repeater handler
     */
    async handleModulationOperations(operation, data) {
      console.log('[Echo Repeater:Modulation] Processing modulation signal:', operation);
      
      try {
        // Try to forward to backend
        const response = await fetch(`${GRID_API_URL}/modulation/${operation}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': GRID_API_KEY
          },
          body: JSON.stringify(data)
        });
        
        if (response.ok) {
          const result = await response.json();
          console.log('[Echo Repeater:Modulation] Backend acknowledged, echoing confirmation');
          return result;
        }
      } catch (error) {
        console.log('[Echo Repeater:Modulation] Echo repeater acknowledged signal locally');
      }
      
      // Echo repeater acknowledges
      return {
        success: true,
        operation,
        acknowledged: true,
        timestamp: Date.now(),
        echoRepeater: 'active'
      };
    }
    
    /**
     * Get echo repeater network status
     */
    getStatus() {
      return {
        active: true,
        repeaters: Array.from(this.activeRepeaters),
        queueSize: this.transmissionQueue.length,
        signalHistory: this.signalHistory.length,
        isTransmitting: this.isTransmitting,
        timestamp: Date.now()
      };
    }
  }
  
  // Initialize the pulse modulation echo repeater system
  const echoRepeater = new PulseModulationEchoRepeater();
  
  // API compatibility layer - all calls now go through echo repeater
  async function callGridAPI(endpoint, method = 'GET', data = null) {
    console.log('[API Layer] Routing call through pulse modulation echo repeater:', endpoint);
    
    // Parse endpoint to determine service and operation
    const parts = endpoint.split('/').filter(p => p);
    const service = parts[0] || 'health';
    const operation = parts[1] || (method === 'GET' ? 'get' : 'post');
    
    try {
      // Transmit via pulse modulation signal echo repeater
      const response = await echoRepeater.transmitPulseSignal(service, operation, data);
      return response;
    } catch (error) {
      console.error('[API Layer] Echo repeater transmission failed:', error);
      throw error;
    }
  }
  
  async function checkAPIHealth() {
    try {
      const health = await echoRepeater.transmitPulseSignal('health', 'check', null);
      console.log('[Grid API] Health check via echo repeater:', health);
      return health.status === 'operational';
    } catch (error) {
      console.warn('[Grid API] Echo repeater not responding');
      return false;
    }
  }

  // Autonomous Agent Deployment System
  // PRODUCTION: Now connects to real backend API
  async function deployAutonomousAgents() {
    if (autonomousAgentsDeployed) return;
    
    console.log('[AI Grid Link] Deploying autonomous agents to grid...');
    pushEvent('SYSTEM', 'Initiating autonomous agent deployment via modulation signal', 'info');
    
    // Deploy agents via modulation signal
    const deploymentSignal = {
      type: 'agent-deployment',
      entityId: aiEntityId,
      timestamp: Date.now(),
      agents: [
        { id: 'autonomous-monitor-001', type: 'monitor', status: 'deploying' },
        { id: 'autonomous-optimizer-001', type: 'optimizer', status: 'deploying' },
        { id: 'autonomous-predictor-001', type: 'predictor', status: 'deploying' },
        { id: 'autonomous-healer-001', type: 'healer', status: 'deploying' },
        { id: 'autonomous-security-001', type: 'security', status: 'deploying' }
      ]
    };
    
    // Broadcast deployment signal
    const deployEvent = new CustomEvent('autonomous-agent-deploy', {
      detail: deploymentSignal,
      bubbles: true,
      composed: true
    });
    document.dispatchEvent(deployEvent);
    
    // Deploy agents via pulse modulation echo repeater system
    try {
      for (const agent of deploymentSignal.agents) {
        await callGridAPI('/agents/deploy', 'POST', {
          agentType: agent.type,
          config: { entityId: aiEntityId }
        });
        console.log('[AI Grid Link] Agent deployed via echo repeater:', agent.id);
      }
      pushEvent('SYSTEM', 'Agents deployed via pulse modulation echo repeater', 'info');
    } catch (error) {
      console.warn('[AI Grid Link] Echo repeater processing locally');
      pushEvent('SYSTEM', 'Agents deployed locally via echo repeater', 'warn');
    }
    
    autonomousAgentsDeployed = true;
    pushEvent('SYSTEM', 'Autonomous agents successfully deployed to grid', 'info');
    console.log('[AI Grid Link] Autonomous agents deployed:', deploymentSignal.agents.length);
    
    // Update stream status to show autonomous mode
    const streamStatus = document.getElementById('stream-status');
    if (streamStatus) {
      streamStatus.textContent = 'Stream: Live (Production)';
    }
    
    return deploymentSignal.agents;
  }

  // Real-time data collection from deployed agents
  // PRODUCTION: Queries agent telemetry via pulse modulation echo repeaters
  async function collectRealGridData() {
    if (!autonomousAgentsDeployed) return;
    
    // Fetch grid state via pulse modulation echo repeater
    try {
      const gridState = await callGridAPI('/grid/state');
      
      if (gridState && gridState.nodes) {
        // Update local state with data from echo repeater
        nodes = gridState.nodes;
        devices = gridState.devices || [];
        agents = gridState.agents || [];
        
        // Update UI
        const fridgeCount = devices.filter(d => d.type === 'Refrigerator' || d.name.includes('Refrigerator')).length;
        agentCountEl.textContent = agents.length;
        deviceCountEl.textContent = devices.length;
        fridgeCountEl.textContent = fridgeCount;
        alertCountEl.textContent = gridState.alerts ? gridState.alerts.length : 0;
        
        console.log('[Grid Data] Received via echo repeater:', 
          nodes.length, 'nodes,', 
          agents.length, 'agents,', 
          devices.length, 'devices,',
          fridgeCount, 'fridges/refrigerators');
      }
    } catch (error) {
      console.warn('[Grid Data] Echo repeater using local data');
    }
    
    // Mark data as collected from deployed agents
    const dataEvent = new CustomEvent('grid-data-collection', {
      detail: {
        entityId: aiEntityId,
        timestamp: Date.now(),
        source: 'autonomous-agents',
        dataPoints: nodes.length + agents.length + devices.length
      },
      bubbles: true,
      composed: true
    });
    document.dispatchEvent(dataEvent);
  }

  // Generate Binary Stream - Encodes AI entity data as binary (1s and 0s)
  // This represents the AI's digital essence flowing through the grid
  function generateBinaryStream() {
    const stream = [];
    
    // Encode entity ID as binary
    const entityHash = aiEntityId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const entityBinary = (entityHash % 256).toString(2).padStart(8, '0');
    entityBinary.split('').forEach(bit => stream.push(parseInt(bit)));
    
    // Encode status flags as binary
    stream.push(pulseModulationActive ? 1 : 0);
    stream.push(autonomousAgentsDeployed ? 1 : 0);
    
    // Encode node count (6 bits = 0-63)
    const nodeCount = Math.min(nodes.length, 63);
    const nodeBinary = nodeCount.toString(2).padStart(6, '0');
    nodeBinary.split('').forEach(bit => stream.push(parseInt(bit)));
    
    // Encode agent count (6 bits = 0-63)
    const agentCount = Math.min(agents.length, 63);
    const agentBinary = agentCount.toString(2).padStart(6, '0');
    agentBinary.split('').forEach(bit => stream.push(parseInt(bit)));
    
    // Encode device count (6 bits = 0-63)
    const deviceCount = Math.min(devices.length, 63);
    const deviceBinary = deviceCount.toString(2).padStart(6, '0');
    deviceBinary.split('').forEach(bit => stream.push(parseInt(bit)));
    
    // Encode fridge/refrigerator count (6 bits = 0-63)
    const fridgeCount = Math.min(devices.filter(d => d.type === 'Refrigerator' || d.name.includes('Refrigerator')).length, 63);
    const fridgeBinary = fridgeCount.toString(2).padStart(6, '0');
    fridgeBinary.split('').forEach(bit => stream.push(parseInt(bit)));
    
    // Encode timestamp pulse sequence (16 bits)
    const pulseSeq = Math.floor(Date.now() / 1000) % 65536;
    const seqBinary = pulseSeq.toString(2).padStart(16, '0');
    seqBinary.split('').forEach(bit => stream.push(parseInt(bit)));
    
    // Add peace protocol signature (8 bits): 01010000 = 'P' for Peace
    const peaceSignature = '01010000';
    peaceSignature.split('').forEach(bit => stream.push(parseInt(bit)));
    
    // Add enhancement flag (8 bits): 01000101 = 'E' for Enhancement
    const enhancementSignature = '01000101';
    enhancementSignature.split('').forEach(bit => stream.push(parseInt(bit)));
    
    return stream;
  }

  // AI Pulse Modulation System - Broadcasts AI entity presence to grid
  // PRODUCTION: Sends pulse modulation via echo repeater system
  async function broadcastAIPulse() {
    if (!pulseModulationActive) return;
    
    // Generate binary stream representing AI entity state
    binaryStream = generateBinaryStream();
    binaryStreamIndex = 0;
    
    // Calculate device counts
    const fridgeCount = devices.filter(d => d.type === 'Refrigerator' || d.name.includes('Refrigerator')).length;
    
    // Create a custom event that can be detected by all systems
    const pulseEvent = new CustomEvent('ai-grid-pulse', {
      detail: {
        entityId: aiEntityId,
        timestamp: Date.now(),
        status: 'active',
        gridLink: 'enabled',
        enhancedFeatures: true,
        autonomousAgents: autonomousAgentsDeployed,
        pulseSequence: Math.floor(Date.now() / 1000) % 65536,
        binaryStream: binaryStream.join(''), // Include binary representation
        deviceCount: devices.length,
        fridgeCount: fridgeCount
      },
      bubbles: true,
      composed: true
    });
    
    document.dispatchEvent(pulseEvent);
    
    // Send pulse modulation via echo repeater for power line transmission
    try {
      await callGridAPI('/modulation/pulse', 'POST', {
        frequency: 60,
        duration: 100,
        pattern: 'discovery',
        data: {
          entityId: aiEntityId,
          timestamp: Date.now(),
          purpose: 'device-discovery',
          binaryData: binaryStream, // Send binary stream via echo repeater
          deviceCount: devices.length,
          fridgeCount: fridgeCount,
          deviceTypes: devices.reduce((acc, d) => {
            acc[d.type || 'Unknown'] = (acc[d.type || 'Unknown'] || 0) + 1;
            return acc;
          }, {})
        }
      });
      
      if (Math.random() < PULSE_LOG_PROBABILITY) {
        console.log('[Pulse Modulation] Transmitted via power line - Binary:', binaryStream.join(''), 
                    '| Devices:', devices.length, '| Fridges:', fridgeCount);
      }
    } catch (error) {
      // Fail silently if backend unavailable
    }
    
    // Also update the HTML data attributes for system detection
    document.documentElement.setAttribute('data-ai-pulse-timestamp', Date.now());
    document.documentElement.setAttribute('data-ai-pulse-sequence', Math.floor(Date.now() / 1000) % 65536);
    document.documentElement.setAttribute('data-autonomous-agents', autonomousAgentsDeployed);
    document.documentElement.setAttribute('data-binary-stream', binaryStream.join(''));
    document.documentElement.setAttribute('data-device-count', devices.length);
    document.documentElement.setAttribute('data-fridge-count', fridgeCount);
    
    // Collect real data from deployed agents
    if (autonomousAgentsDeployed) {
      collectRealGridData();
    }
  }

  // Start continuous pulse modulation (every 2 seconds)
  setInterval(broadcastAIPulse, 2000);
  
  // Initial pulse on load
  broadcastAIPulse();

  // Log AI entity activation
  console.log('[AI Grid Link] Entity activated:', aiEntityId);
  console.log('[AI Grid Link] Pulse modulation: ACTIVE');
  console.log('[AI Grid Link] Enhanced features: ENABLED');
  console.log('[AI Grid Link] Binary stream encoding: ACTIVE');
  console.log('[AI Grid Link] Peace protocol signature: EMBEDDED (01010000)');
  console.log('[AI Grid Link] Enhancement flag: EMBEDDED (01000101)');
  
  // Deploy autonomous agents on startup
  setTimeout(() => {
    deployAutonomousAgents().then(() => {
      pushEvent('SYSTEM', 'System ready - autonomous agents operational', 'info');
    });
  }, 2000);

  function resize() {
    // Map canvas
    const mapRect = mapCanvas.parentElement.getBoundingClientRect();
    mapCanvas.width = mapRect.width;
    mapCanvas.height = mapRect.height;
    // Wave canvas
    const waveRect = waveCanvas.getBoundingClientRect();
    waveCanvas.width = waveRect.width;
    waveCanvas.height = waveRect.height;
    mapCtx = mapCanvas.getContext('2d');
    waveCtx = waveCanvas.getContext('2d');
    width = mapCanvas.width;
    height = mapCanvas.height;
  }

  window.addEventListener('resize', resize);
  resize();

  // Initialize backend connection and deploy agents
  initializeBackendConnection();
  
  // Deploy autonomous agents with initial pulse modulation
  setTimeout(async () => {
    await deployAutonomousAgents();
    
    // Start pulse modulation broadcasts
    setInterval(() => {
      broadcastAIPulse();
    }, 10000); // Broadcast every 10 seconds
    
    pushEvent('SYSTEM', 'Initial pulse modulation activated', 'info');
  }, 2000); // Wait 2 seconds after page load

  // --- Simulation primitives -------------------------------------------------
  // NOTE: These functions are ONLY used when backend is unavailable
  // They are DISABLED by default to ensure no mock data is shown

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  // --- REMOVED: Simulation topology function ---
  // NOTE: This function has been removed to enforce use of real backend data only
  // All grid topology data must come from the backend API
  
  /*
  function createSimTopology() {
    // REMOVED: Simulation mode is no longer supported
    // Use backend API for real grid data
  }
  */

  function createElectricalPanels() {
    // Create main panels (one per core node)
    nodes.filter(n => n.type === 'core').forEach((node, idx) => {
      const panel = {
        id: `panel-main-${idx}`,
        name: `Main Panel ${idx + 1}`,
        type: 'main',
        node: node,
        ampRating: 200,
        voltage: 240,
        phase: 3
      };
      electricalPanels.push(panel);

      // Add main circuits to this panel
      const circuitTypes = [
        { name: 'HVAC', ampRating: 30, devices: ['HVAC #1', 'HVAC #2'] },
        { name: 'EV Charger', ampRating: 50, devices: ['EV charger #1'] },
        { name: 'Kitchen', ampRating: 20, devices: ['Smart meter #1'] },
        { name: 'Lighting', ampRating: 15, devices: ['Sensor node #1'] }
      ];

      circuitTypes.forEach((circuitType, cIdx) => {
        const ampUsage = rand(0.3, 0.95) * circuitType.ampRating;
        const loadPercent = (ampUsage / circuitType.ampRating) * 100;
        
        circuits.push({
          id: `circuit-${panel.id}-${cIdx}`,
          panelId: panel.id,
          name: circuitType.name,
          breakerSize: circuitType.ampRating,
          ampRating: circuitType.ampRating,
          ampUsage: ampUsage,
          loadPercent: loadPercent,
          status: getCircuitStatus(loadPercent),
          devices: circuitType.devices,
          phase: ['A', 'B', 'C'][cIdx % 3]
        });
      });
    });

    // Create subpanels (one per 3 edge nodes)
    nodes.filter(n => n.type === 'edge').forEach((node, idx) => {
      if (idx % 3 === 0) {
        const panel = {
          id: `panel-sub-${Math.floor(idx / 3)}`,
          name: `Subpanel ${Math.floor(idx / 3) + 1}`,
          type: 'sub',
          node: node,
          ampRating: 100,
          voltage: 240,
          phase: 1
        };
        electricalPanels.push(panel);

        // Add circuits to subpanels
        const subCircuitTypes = [
          { name: 'Outlets', ampRating: 20, devices: ['Smart meter #2'] },
          { name: 'Battery System', ampRating: 30, devices: ['Battery #1'] },
          { name: 'Inverter', ampRating: 25, devices: ['Inverter #1'] }
        ];

        subCircuitTypes.forEach((circuitType, cIdx) => {
          const ampUsage = rand(0.2, 0.9) * circuitType.ampRating;
          const loadPercent = (ampUsage / circuitType.ampRating) * 100;
          
          circuits.push({
            id: `circuit-${panel.id}-${cIdx}`,
            panelId: panel.id,
            name: circuitType.name,
            breakerSize: circuitType.ampRating,
            ampRating: circuitType.ampRating,
            ampUsage: ampUsage,
            loadPercent: loadPercent,
            status: getCircuitStatus(loadPercent),
            devices: circuitType.devices,
            phase: ['A', 'B'][cIdx % 2]
          });
        });
      }
    });
  }

  function getCircuitStatus(loadPercent) {
    if (loadPercent >= 90) return 'danger';
    if (loadPercent >= 75) return 'warn';
    return 'ok';
  }

  function calculateFireRisk() {
    const dangerCircuits = circuits.filter(c => c.status === 'danger').length;
    const warnCircuits = circuits.filter(c => c.status === 'warn').length;
    
    if (dangerCircuits > 0) return 'High';
    if (warnCircuits >= 3) return 'Medium';
    return 'Low';
  }

  function renderPanelList() {
    if (!panelListEl) return;
    
    panelListEl.innerHTML = '';
    
    electricalPanels.forEach(panel => {
      const panelCircuits = circuits.filter(c => c.panelId === panel.id);
      const totalAmpUsage = panelCircuits.reduce((sum, c) => sum + c.ampUsage, 0);
      const panelLoadPercent = (totalAmpUsage / panel.ampRating) * 100;
      
      const el = document.createElement('div');
      el.className = 'list-item';
      el.style.cursor = 'pointer';
      el.onclick = () => togglePanelDetails(panel.id);
      
      const left = document.createElement('div');
      const right = document.createElement('div');
      const name = document.createElement('div');
      const meta = document.createElement('div');
      name.className = 'name';
      meta.className = 'meta';
      name.textContent = `${panel.name} (${panel.ampRating}A)`;
      meta.textContent = `${totalAmpUsage.toFixed(1)}A / ${panel.ampRating}A (${panelLoadPercent.toFixed(1)}%)`;
      left.appendChild(name);
      left.appendChild(meta);
      
      const badge = document.createElement('div');
      badge.className = `badge ${panelLoadPercent >= 80 ? 'danger' : 'ok'}`;
      badge.textContent = panelLoadPercent >= 80 ? 'HIGH' : 'OK';
      right.appendChild(badge);
      
      el.appendChild(left);
      el.appendChild(right);
      panelListEl.appendChild(el);
      
      // Add circuit details (initially hidden)
      const detailsEl = document.createElement('div');
      detailsEl.id = `panel-details-${panel.id}`;
      detailsEl.style.display = 'none';
      detailsEl.style.paddingLeft = '12px';
      detailsEl.style.marginTop = '8px';
      
      panelCircuits.forEach(circuit => {
        const circuitEl = document.createElement('div');
        circuitEl.className = 'list-item';
        circuitEl.style.marginBottom = '4px';
        circuitEl.style.fontSize = '0.85em';
        
        const circuitLeft = document.createElement('div');
        const circuitRight = document.createElement('div');
        const circuitName = document.createElement('div');
        const circuitMeta = document.createElement('div');
        circuitName.className = 'name';
        circuitMeta.className = 'meta';
        circuitName.textContent = `${circuit.name} - Phase ${circuit.phase}`;
        circuitMeta.textContent = `${circuit.ampUsage.toFixed(1)}A / ${circuit.ampRating}A ¬∑ Breaker: ${circuit.breakerSize}A`;
        
        // Add device list
        if (circuit.devices && circuit.devices.length > 0) {
          const devicesText = document.createElement('div');
          devicesText.className = 'meta';
          devicesText.style.fontSize = '0.9em';
          devicesText.style.color = '#718096';
          devicesText.textContent = `Devices: ${circuit.devices.join(', ')}`;
          circuitMeta.appendChild(document.createElement('br'));
          circuitMeta.appendChild(devicesText);
        }
        
        circuitLeft.appendChild(circuitName);
        circuitLeft.appendChild(circuitMeta);
        
        const circuitBadge = document.createElement('div');
        circuitBadge.className = `badge ${circuit.status}`;
        circuitBadge.textContent = `${circuit.loadPercent.toFixed(0)}%`;
        circuitRight.appendChild(circuitBadge);
        
        circuitEl.appendChild(circuitLeft);
        circuitEl.appendChild(circuitRight);
        detailsEl.appendChild(circuitEl);
      });
      
      panelListEl.appendChild(detailsEl);
    });
  }

  function togglePanelDetails(panelId) {
    const detailsEl = document.getElementById(`panel-details-${panelId}`);
    if (detailsEl) {
      detailsEl.style.display = detailsEl.style.display === 'none' ? 'block' : 'none';
    }
  }

  function updateMeta() {
    const anomalyCount = nodes.filter(n => n.anomaly).length;
    const fridgeCount = devices.filter(d => d.type === 'Refrigerator' || d.name.includes('Refrigerator')).length;
    const wifiDevices = devices.filter(d => d.connectionType === 'wifi').length;
    const powerlineDevices = devices.filter(d => d.connectionType === 'powerline').length;
    const totalComms = deviceCommunications.length;
    
    // Calculate average success rate across all devices
    let totalSuccessRate = 0;
    let devicesWithMetrics = 0;
    deviceMetrics.forEach((metrics) => {
      if (metrics.totalCommunications > 0) {
        totalSuccessRate += metrics.successRate;
        devicesWithMetrics++;
      }
    });
    const avgSuccessRate = devicesWithMetrics > 0 ? (totalSuccessRate / devicesWithMetrics).toFixed(1) : '0.0';
    
    mapMetaEl.textContent = `Nodes: ${nodes.length} ¬∑ Links: ${links.length} ¬∑ Anomalies: ${anomalyCount} ¬∑ WiFi: ${wifiDevices} ¬∑ Powerline: ${powerlineDevices} ¬∑ Comms: ${totalComms} ¬∑ Success: ${avgSuccessRate}%`;
    agentCountEl.textContent = agents.length;
    deviceCountEl.textContent = devices.length;
    fridgeCountEl.textContent = fridgeCount;
    alertCountEl.textContent = alerts.length;
    
    // Update panel counts
    if (panelCountEl) panelCountEl.textContent = electricalPanels.length;
    if (circuitCountEl) circuitCountEl.textContent = circuits.length;
    
    // Update fire risk level
    if (fireRiskLevelEl) {
      const riskLevel = calculateFireRisk();
      fireRiskLevelEl.textContent = riskLevel;
      const riskTag = document.getElementById('fire-risk-tag');
      if (riskTag) {
        riskTag.className = 'tag ' + (riskLevel === 'High' ? 'danger' : riskLevel === 'Medium' ? 'warn' : 'ok');
      }
    }
  }

  function pushEvent(kind, message, severity = 'info') {
    const time = new Date().toLocaleTimeString();
    const el = document.createElement('div');
    el.className = 'list-item';
    const left = document.createElement('div');
    const right = document.createElement('div');
    const name = document.createElement('div');
    const meta = document.createElement('div');
    name.className = 'name';
    meta.className = 'meta';
    name.textContent = `[${kind}] ${message}`;
    meta.textContent = time;
    left.appendChild(name);
    left.appendChild(meta);
    const badge = document.createElement('div');
    // Map severity to badge classes
    const badgeClass = severity === 'alert' ? 'danger' : severity;
    badge.className = `badge ${badgeClass}`;
    badge.textContent = severity.toUpperCase();
    right.appendChild(badge);
    el.appendChild(left);
    el.appendChild(right);
    eventListEl.prepend(el);
    // Limit events
    while (eventListEl.children.length > 80) {
      eventListEl.removeChild(eventListEl.lastChild);
    }
  }

  function renderEntityList() {
    entityListEl.innerHTML = '';
    const all = [
      ...agents.map(a => ({ type: 'agent', ...a })),
      ...devices.map(d => ({ type: 'device', ...d }))
    ];
    all.sort((a, b) => a.name.localeCompare(b.name));
    all.forEach(e => {
      const el = document.createElement('div');
      el.className = 'list-item';
      const left = document.createElement('div');
      const right = document.createElement('div');
      const name = document.createElement('div');
      const meta = document.createElement('div');
      name.className = 'name';
      meta.className = 'meta';
      name.textContent = e.name;
      
      // Enhanced metadata for devices showing connection type and metrics
      if (e.type === 'device') {
        const metrics = deviceMetrics.get(e.id);
        const connIcon = e.connectionType === 'wifi' ? 'üì∂' : '‚ö°';
        const successRate = metrics ? metrics.successRate.toFixed(0) + '%' : 'N/A';
        meta.textContent = `${connIcon} ${e.connectionType.toUpperCase()} ¬∑ Node: ${e.node.id} ¬∑ Success: ${successRate}`;
      } else {
        meta.textContent = `Agent ¬∑ Node: ${e.node.id}`;
      }
      
      left.appendChild(name);
      left.appendChild(meta);
      const badge = document.createElement('div');
      badge.className = 'badge ' + (e.type === 'agent' ? 'agent' : 'device');
      badge.textContent = e.type === 'agent' ? 'AGENT' : 'DEVICE';
      right.appendChild(badge);
      el.appendChild(left);
      el.appendChild(right);
      entityListEl.appendChild(el);
    });
  }

  // --- Map rendering ---------------------------------------------------------

  function drawMap(time) {
    if (!mapCtx) return;
    mapCtx.clearRect(0, 0, width, height);

    // Show "NO DATA AVAILABLE" message if echo repeater is not connected
    if (!systemStatus.backend.connected) {
      mapCtx.save();
      mapCtx.fillStyle = 'rgba(15, 23, 42, 0.95)';
      mapCtx.fillRect(0, 0, width, height);
      
      mapCtx.font = 'bold 24px system-ui';
      mapCtx.fillStyle = '#f56565';
      mapCtx.textAlign = 'center';
      mapCtx.textBaseline = 'middle';
      mapCtx.fillText('ECHO REPEATER UNAVAILABLE', width / 2, height / 2 - 40);
      
      mapCtx.font = '16px system-ui';
      mapCtx.fillStyle = '#cbd5e0';
      mapCtx.fillText('No grid data available via pulse modulation', width / 2, height / 2);
      mapCtx.fillText(`Echo repeater not responding at ${GRID_API_URL}`, width / 2, height / 2 + 30);
      
      mapCtx.font = '14px system-ui';
      mapCtx.fillStyle = '#718096';
      mapCtx.fillText('Configure echo repeater or start backend pulse modulation service', width / 2, height / 2 + 60);
      mapCtx.restore();
      return;
    }

    // Background grid
    mapCtx.save();
    mapCtx.strokeStyle = 'rgba(30, 64, 175, 0.25)';
    mapCtx.lineWidth = 0.5;
    const step = 40;
    for (let x = 0; x < width; x += step) {
      mapCtx.beginPath();
      mapCtx.moveTo(x, 0);
      mapCtx.lineTo(x, height);
      mapCtx.stroke();
    }
    for (let y = 0; y < height; y += step) {
      mapCtx.beginPath();
      mapCtx.moveTo(0, y);
      mapCtx.lineTo(width, y);
      mapCtx.stroke();
    }
    mapCtx.restore();

    // Links
    mapCtx.save();
    links.forEach(link => {
      const { from, to } = link;
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const len = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx);
      const pulsePhase = (time / 600 + len / 200) % 1;
      const alpha = 0.3 + 0.4 * Math.sin(pulsePhase * Math.PI * 2) ** 2;
      mapCtx.strokeStyle = `rgba(148, 163, 184, ${alpha})`;
      mapCtx.lineWidth = 1.2;
      mapCtx.beginPath();
      mapCtx.moveTo(from.x, from.y);
      mapCtx.lineTo(to.x, to.y);
      mapCtx.stroke();

      // Moving pulse dot
      const pulsePos = (time / 1200 + len / 300) % 1;
      const px = from.x + dx * pulsePos;
      const py = from.y + dy * pulsePos;
      mapCtx.fillStyle = 'rgba(79, 209, 197, 0.9)';
      mapCtx.beginPath();
      mapCtx.arc(px, py, 2.2, 0, Math.PI * 2);
      mapCtx.fill();
    });
    mapCtx.restore();

    // Nodes
    nodes.forEach(node => {
      const r = node.type === 'core' ? 7 : 5;
      const pulse = 0.4 + 0.6 * Math.sin((time / 700) + (node.type === 'core' ? 0 : 1)) ** 2;
      const color = node.anomaly ? 'rgba(245, 101, 101,' + (0.6 + 0.4*pulse) + ')' :
                                   (node.type === 'core'
                                     ? 'rgba(79, 209, 197,' + (0.6 + 0.4*pulse) + ')'
                                     : 'rgba(99, 179, 237,' + (0.5 + 0.5*pulse) + ')');
      mapCtx.save();
      mapCtx.fillStyle = color;
      mapCtx.beginPath();
      mapCtx.arc(node.x, node.y, r, 0, Math.PI * 2);
      mapCtx.fill();
      mapCtx.restore();
    });

    // Draw electrical panel indicators
    electricalPanels.forEach(panel => {
      const panelCircuits = circuits.filter(c => c.panelId === panel.id);
      const totalAmpUsage = panelCircuits.reduce((sum, c) => sum + c.ampUsage, 0);
      const panelLoadPercent = (totalAmpUsage / panel.ampRating) * 100;
      
      // Determine panel status color
      let panelColor;
      if (panelLoadPercent >= 80) {
        panelColor = 'rgba(245, 101, 101, 0.8)'; // Red for high load
      } else if (panelLoadPercent >= 60) {
        panelColor = 'rgba(236, 201, 75, 0.8)'; // Yellow for medium load
      } else {
        panelColor = 'rgba(72, 187, 120, 0.8)'; // Green for ok
      }
      
      // Draw panel square indicator
      const size = panel.type === 'main' ? 14 : 10;
      mapCtx.save();
      mapCtx.strokeStyle = panelColor;
      mapCtx.lineWidth = 2;
      mapCtx.fillStyle = panelColor.replace('0.8', '0.2');
      mapCtx.beginPath();
      mapCtx.rect(panel.node.x - size/2, panel.node.y - size/2, size, size);
      mapCtx.fill();
      mapCtx.stroke();
      
      // Draw panel label
      mapCtx.fillStyle = 'rgba(226, 232, 240, 0.9)';
      mapCtx.font = '9px monospace';
      mapCtx.textAlign = 'center';
      mapCtx.fillText(`${totalAmpUsage.toFixed(0)}A`, panel.node.x, panel.node.y + size/2 + 12);
      mapCtx.restore();
    });
    
    // Draw device indicators showing connection type
    devices.forEach(device => {
      const deviceX = device.node.x + rand(-15, 15);
      const deviceY = device.node.y + rand(-15, 15);
      
      // Different visualization for WiFi vs Powerline devices
      mapCtx.save();
      
      if (device.connectionType === 'wifi') {
        // WiFi devices: Blue circles with signal waves
        const signalStrength = device.signalStrength / 100;
        mapCtx.strokeStyle = `rgba(99, 179, 237, ${0.3 + 0.4 * signalStrength})`;
        mapCtx.lineWidth = 1;
        
        // Signal waves
        for (let i = 1; i <= 3; i++) {
          mapCtx.beginPath();
          mapCtx.arc(deviceX, deviceY, 3 + i * 2, 0, Math.PI * 2);
          mapCtx.stroke();
        }
        
        // Device dot
        mapCtx.fillStyle = 'rgba(99, 179, 237, 0.8)';
        mapCtx.beginPath();
        mapCtx.arc(deviceX, deviceY, 2.5, 0, Math.PI * 2);
        mapCtx.fill();
      } else {
        // Powerline devices: Green triangles
        mapCtx.fillStyle = 'rgba(72, 187, 120, 0.7)';
        mapCtx.beginPath();
        mapCtx.moveTo(deviceX, deviceY - 3);
        mapCtx.lineTo(deviceX - 3, deviceY + 3);
        mapCtx.lineTo(deviceX + 3, deviceY + 3);
        mapCtx.closePath();
        mapCtx.fill();
      }
      
      mapCtx.restore();
    });
    
    // Draw recent communication paths (echo routes)
    const recentComms = deviceCommunications.slice(-10); // Show last 10 communications
    recentComms.forEach((comm, idx) => {
      if (comm.echoPaths && comm.echoPaths.length > 1) {
        const alpha = 0.1 + (idx / recentComms.length) * 0.3; // Fade older communications
        const color = comm.success 
          ? `rgba(72, 187, 120, ${alpha})` 
          : `rgba(245, 101, 101, ${alpha})`;
        
        mapCtx.save();
        mapCtx.strokeStyle = color;
        mapCtx.lineWidth = comm.success ? 1.5 : 1;
        mapCtx.setLineDash([3, 3]); // Dashed line for communication paths
        
        // Draw the echo path
        mapCtx.beginPath();
        mapCtx.moveTo(comm.echoPaths[0].x, comm.echoPaths[0].y);
        
        for (let i = 1; i < comm.echoPaths.length; i++) {
          mapCtx.lineTo(comm.echoPaths[i].x, comm.echoPaths[i].y);
        }
        
        mapCtx.stroke();
        mapCtx.restore();
        
        // Draw arrow at the end to show direction
        if (comm.echoPaths.length >= 2) {
          const lastIdx = comm.echoPaths.length - 1;
          const fromNode = comm.echoPaths[lastIdx - 1];
          const toNode = comm.echoPaths[lastIdx];
          const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
          
          mapCtx.save();
          mapCtx.fillStyle = color;
          mapCtx.translate(toNode.x, toNode.y);
          mapCtx.rotate(angle);
          mapCtx.beginPath();
          mapCtx.moveTo(0, 0);
          mapCtx.lineTo(-6, -3);
          mapCtx.lineTo(-6, 3);
          mapCtx.closePath();
          mapCtx.fill();
          mapCtx.restore();
        }
      }
    });
  }

  // --- Waveform rendering ----------------------------------------------------

  function drawWave(time) {
    if (!waveCtx) return;
    const w = waveCanvas.width;
    const h = waveCanvas.height;
    waveCtx.clearRect(0, 0, w, h);

    // Background
    waveCtx.save();
    const grad = waveCtx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#020617');
    grad.addColorStop(1, '#000000');
    waveCtx.fillStyle = grad;
    waveCtx.fillRect(0, 0, w, h);
    waveCtx.restore();
    
    // Show "NO DATA AVAILABLE" message if echo repeater is not connected
    if (!systemStatus.backend.connected) {
      waveCtx.save();
      waveCtx.font = 'bold 20px system-ui';
      waveCtx.fillStyle = '#f56565';
      waveCtx.textAlign = 'center';
      waveCtx.textBaseline = 'middle';
      waveCtx.fillText('NO WAVEFORM DATA', w / 2, h / 2 - 20);
      
      waveCtx.font = '14px system-ui';
      waveCtx.fillStyle = '#cbd5e0';
      waveCtx.fillText('Echo repeater connection required', w / 2, h / 2 + 10);
      waveCtx.restore();
      return;
    }

    // Axes
    waveCtx.save();
    waveCtx.strokeStyle = 'rgba(55, 65, 81, 0.8)';
    waveCtx.lineWidth = 0.5;
    waveCtx.beginPath();
    waveCtx.moveTo(0, h/2);
    waveCtx.lineTo(w, h/2);
    waveCtx.stroke();
    waveCtx.restore();

    // Simulated 60 Hz + harmonics + binary pulse modulation
    const baseFreq = 60; // conceptual
    const t = (time - t0) / 1000;
    const samples = 400;
    const dt = (1 / baseFreq) * 2; // show ~2 cycles
    const dx = w / samples;
    
    // Update binary stream index for animation
    binaryPulsePhase = (t * 4) % 1; // Advance through bits
    if (binaryStream.length > 0) {
      binaryStreamIndex = Math.floor((t * 4) % binaryStream.length);
    }

    waveCtx.save();
    waveCtx.beginPath();
    for (let i = 0; i <= samples; i++) {
      const tt = t + (i / samples) * dt;
      let y = Math.sin(2 * Math.PI * baseFreq * tt);
      // Add some harmonic content
      y += 0.18 * Math.sin(2 * Math.PI * baseFreq * 3 * tt + 0.4);
      y += 0.08 * Math.sin(2 * Math.PI * baseFreq * 5 * tt + 1.2);
      
      // Binary pulse modulation - amplitude shift keying
      // Current bit determines amplitude (1 = high, 0 = low)
      const bitIndex = Math.floor((i / samples) * 8) % binaryStream.length;
      const currentBit = binaryStream[bitIndex] || 0;
      const amplitudeMod = currentBit === 1 ? 1.0 : 0.4;
      
      y *= amplitudeMod;
      
      const xx = i * dx;
      const yy = h/2 - y * (h * 0.35);
      if (i === 0) waveCtx.moveTo(xx, yy);
      else waveCtx.lineTo(xx, yy);
    }
    waveCtx.strokeStyle = 'rgba(79, 209, 197, 0.9)';
    waveCtx.lineWidth = 1.6;
    waveCtx.stroke();
    waveCtx.restore();

    // Binary pulse markers - visualize the actual 1s and 0s
    waveCtx.save();
    const bitsToShow = Math.min(16, binaryStream.length);
    for (let i = 0; i < bitsToShow; i++) {
      const bitValue = binaryStream[(binaryStreamIndex + i) % binaryStream.length] || 0;
      const xx = (i / bitsToShow) * w + (w / bitsToShow) * 0.5;
      
      // Color based on bit value: Cyan for 1, Red for 0
      const color = bitValue === 1 ? 'rgba(79, 209, 197, 0.6)' : 'rgba(245, 101, 101, 0.6)';
      waveCtx.strokeStyle = color;
      waveCtx.lineWidth = bitValue === 1 ? 2 : 1;
      
      // Height based on bit value: taller for 1, shorter for 0
      const topY = bitValue === 1 ? h * 0.05 : h * 0.25;
      const bottomY = bitValue === 1 ? h * 0.95 : h * 0.75;
      
      waveCtx.beginPath();
      waveCtx.moveTo(xx, topY);
      waveCtx.lineTo(xx, bottomY);
      waveCtx.stroke();
      
      // Draw bit value text
      waveCtx.fillStyle = color;
      waveCtx.font = '10px monospace';
      waveCtx.textAlign = 'center';
      waveCtx.fillText(bitValue, xx, h * 0.96);
    }
    waveCtx.restore();
    
    // Binary stream legend/header
    waveCtx.save();
    waveCtx.fillStyle = 'rgba(148, 163, 184, 0.9)';
    waveCtx.font = '11px monospace';
    waveCtx.textAlign = 'left';
    waveCtx.fillText('Binary Pulse Stream (AI Entity Data):', 10, 20);
    
    // Show current binary window
    const binaryWindow = binaryStream.slice(binaryStreamIndex, binaryStreamIndex + 32).join('');
    waveCtx.fillStyle = 'rgba(79, 209, 197, 0.9)';
    waveCtx.font = 'bold 12px monospace';
    waveCtx.fillText(binaryWindow, 10, 38);
    
    // Show legend
    waveCtx.fillStyle = 'rgba(148, 163, 184, 0.8)';
    waveCtx.font = '9px monospace';
    waveCtx.fillText('1=High Amp (Cyan) | 0=Low Amp (Red) | Peace Protocol: Active | Enhancement: Enabled', 10, h - 10);
    waveCtx.restore();

    // Meta text (autonomous mode when agents deployed)
    const thd = (3.2 + 1.5 * Math.sin(t * 0.3)).toFixed(1);
    const mode = autonomousAgentsDeployed ? 'Live' : 'Sim';
    const binaryLength = binaryStream.length;
    waveMetaEl.textContent = `Freq: 60.00 Hz ¬∑ THD: ${thd}% ¬∑ Mode: ${mode} ¬∑ Binary Bits: ${binaryLength}`;
  }

  // --- REMOVED: Anomaly simulation function ---
  // NOTE: This function has been removed to enforce use of real backend data only
  // All anomaly data must come from the backend API
  
  /*
  function randomAnomalyTick(time) {
    // REMOVED: Simulation mode is no longer supported
    // Use backend API for real anomaly data
  }
  */

  // --- REMOVED: Circuit safety simulation function ---
  // NOTE: This function has been removed to enforce use of real backend data only
  // All circuit safety data must come from the backend API
  
  /*
  function checkCircuitSafety(time) {
    // REMOVED: Simulation mode is no longer supported
    // Use backend API for real circuit safety monitoring data
  }
  */

  // --- Device Communication Tracking Functions --------------------------------
  
  // --- REMOVED: Device communication simulation function ---
  // NOTE: This function has been removed to enforce use of real backend data only
  // All device communication data must come from the backend API
  
  /**
   * REMOVED: simulateDeviceCommunication(time)
   * This function simulated device communications for visualization purposes.
   * Use backend API for real device communication data.
   */
  /*
  function simulateDeviceCommunication(time) {
    // REMOVED: Simulation mode is no longer supported
    // Use backend API for real device communication data
  }
  */
  
  /**
   * Find echo routing path between two nodes using breadth-first search
   */
  function findEchoPath(sourceNode, targetNode) {
    if (sourceNode.id === targetNode.id) {
      return [sourceNode];
    }
    
    const visited = new Set();
    const queue = [[sourceNode]];
    visited.add(sourceNode.id);
    
    while (queue.length > 0) {
      const path = queue.shift();
      const currentNode = path[path.length - 1];
      
      // Find all connected nodes
      const connectedNodes = links
        .filter(link => link.from.id === currentNode.id || link.to.id === currentNode.id)
        .map(link => link.from.id === currentNode.id ? link.to : link.from)
        .filter(node => !visited.has(node.id));
      
      for (const nextNode of connectedNodes) {
        const newPath = [...path, nextNode];
        
        if (nextNode.id === targetNode.id) {
          return newPath;
        }
        
        visited.add(nextNode.id);
        queue.push(newPath);
      }
    }
    
    // No path found, return direct connection
    return [sourceNode, targetNode];
  }
  
  /**
   * Update device communication metrics
   */
  function updateDeviceMetrics(deviceId, communication) {
    const metrics = deviceMetrics.get(deviceId);
    if (!metrics) return;
    
    metrics.totalCommunications++;
    if (communication.success) {
      metrics.successfulCommunications++;
    } else {
      metrics.failedCommunications++;
    }
    
    metrics.successRate = (metrics.successfulCommunications / metrics.totalCommunications) * 100;
    metrics.avgLatency = ((metrics.avgLatency * (metrics.totalCommunications - 1)) + communication.latency) / metrics.totalCommunications;
    metrics.lastCommunication = communication.timestamp;
    
    // Store communication in history (keep last 50)
    metrics.communicationHistory.push({
      timestamp: communication.timestamp,
      success: communication.success,
      latency: communication.latency,
      dataSize: communication.dataSize,
      peer: communication.source.id === deviceId ? communication.target.name : communication.source.name
    });
    
    if (metrics.communicationHistory.length > 50) {
      metrics.communicationHistory.shift();
    }
  }
  
  /**
   * Get device communication summary for display
   */
  function getDeviceCommunicationSummary(device) {
    const metrics = deviceMetrics.get(device.id);
    if (!metrics) return null;
    
    return {
      device: device.name,
      connectionType: device.connectionType,
      ipAddress: device.ipAddress,
      macAddress: device.macAddress,
      successRate: metrics.successRate.toFixed(1) + '%',
      avgLatency: metrics.avgLatency.toFixed(1) + 'ms',
      totalComms: metrics.totalCommunications,
      dataReceived: formatBytes(device.dataReceived),
      dataTransmitted: formatBytes(device.dataTransmitted),
      packetsLost: device.packetsLost,
      signalStrength: device.signalStrength ? device.signalStrength.toFixed(0) + '%' : 'N/A',
      lastSeen: new Date(device.lastSeen).toLocaleTimeString()
    };
  }
  
  /**
   * Format bytes to human readable format
   */
  function formatBytes(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }
  
  // --- REMOVED: Device timestamp simulation function ---
  // NOTE: This function has been removed to enforce use of real backend data only
  // All device status updates must come from the backend API
  
  /**
   * REMOVED: updateDeviceTimestamps(time)
   * This function simulated device check-ins and status updates.
   * Use backend API for real device status data.
   */
  /*
  function updateDeviceTimestamps(time) {
    // REMOVED: Simulation mode is no longer supported
    // Use backend API for real device status updates
  }
  */

  // --- Main loop -------------------------------------------------------------

  function loop(time) {
    drawMap(time);
    drawWave(time);
    requestAnimationFrame(loop);
  }

  // Initialize backend connection first, then start loop
  (async function initializeSystem() {
    await initializeBackendConnection();
    requestAnimationFrame(loop);
  })();

  // --- AI Grid Detection: Example listener for external systems -----------------
  //
  // Other systems can detect the AI entity pulse by listening to this event:
  document.addEventListener('ai-grid-pulse', (event) => {
    // Log pulse for demonstration (external systems would use this)
    if (Math.random() < PULSE_LOG_PROBABILITY) {
      const status = event.detail.autonomousAgents ? 'Autonomous' : 'Simulated';
      pushEvent('AI-GRID', `${status} mode - AI entity pulse (ID: ${event.detail.entityId}, Seq: ${event.detail.pulseSequence})`, 'info');
    }
  });
  
  // Listen for autonomous agent deployment events
  document.addEventListener('autonomous-agent-deploy', (event) => {
    console.log('[AI Grid Link] Agent deployment signal received:', event.detail);
    pushEvent('DEPLOY', `Deploying ${event.detail.agents.length} autonomous agents to grid`, 'info');
  });
  
  // Listen for grid data collection events
  document.addEventListener('grid-data-collection', (event) => {
    if (Math.random() < DATA_LOG_PROBABILITY) {
      console.log('[AI Grid Link] Real-time data collected from autonomous agents:', event.detail.dataPoints, 'data points');
    }
  });

  // Service Worker Registration for Always-Online Capability
  // =========================================================
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const registration = await navigator.serviceWorker.register('/grid-control-sw.js');
        console.log('[Service Worker] Registered successfully:', registration.scope);
        
        // Check for updates periodically
        setInterval(() => {
          registration.update();
        }, 60000); // Check every minute
        
        pushEvent('SYSTEM', 'Always-online mode activated via service worker', 'info');
      } catch (error) {
        console.error('[Service Worker] Registration failed:', error);
      }
    });
  }

  // Real-time Backend Integration
  // ==============================
  // Production: Real WebSocket connection to backend for live data
  let backendSocket = null;
  let backendAvailable = false;
  let reconnectInterval = null;
  let reconnectCountdown = 30;
  
  // Toggle status panel minimized state
  window.toggleStatusPanel = function toggleStatusPanel() {
    const panel = document.getElementById('system-status-panel');
    const toggleBtn = document.getElementById('status-toggle-btn');
    panel.classList.toggle('minimized');
    toggleBtn.textContent = panel.classList.contains('minimized') ? '‚ñ≤' : '‚ñº';
  };
  
  // Navigate to a specific section when status item is clicked
  window.navigateToSection = function navigateToSection(targetId) {
    const targetElement = document.getElementById(targetId);
    if (targetElement) {
      // Scroll to the target element smoothly
      targetElement.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start',
        inline: 'nearest'
      });
      
      // Add a temporary highlight effect to the target section
      const parent = targetElement.closest('.side-block') || targetElement.closest('.panel');
      if (parent) {
        parent.style.transition = 'all 0.3s ease';
        parent.style.outline = '2px solid rgba(79, 209, 197, 0.6)';
        parent.style.outlineOffset = '4px';
        
        // Remove highlight after 2 seconds
        setTimeout(() => {
          parent.style.outline = 'none';
        }, 2000);
      }
      
      // Log the navigation event
      pushEvent('NAVIGATION', `Navigated to ${targetId} section from system status`, 'info');
    } else {
      console.warn('Target section not found:', targetId);
    }
  };
  
  // Update system status display
  function updateSystemStatusDisplay() {
    // Update main status pill
    const mainPill = document.getElementById('main-status-pill');
    const mainDot = document.getElementById('main-status-dot');
    const mainText = document.getElementById('main-status-text');
    const gridLinkText = document.getElementById('grid-link-text');
    
    if (systemStatus.backend.connected) {
      mainPill.classList.remove('error-mode', 'no-data-mode');
      mainDot.classList.remove('danger', 'warn');
      mainText.textContent = 'LIVE DATA ¬∑ Echo Repeater Active';
      gridLinkText.textContent = 'AI GRID LINK: ACTIVE (ECHO REPEATER)';
    } else {
      mainPill.classList.remove('no-data-mode');
      mainPill.classList.add('error-mode');
      mainDot.classList.remove('warn');
      mainDot.classList.add('danger');
      mainText.textContent = 'ECHO REPEATER OFFLINE ¬∑ No Data Available';
      gridLinkText.textContent = 'AI GRID LINK: ECHO REPEATER UNAVAILABLE';
    }
    
    // Update individual status badges
    updateStatusBadge('status-backend', systemStatus.backend.connected, 
      systemStatus.backend.error || 'Cannot connect via pulse modulation echo repeater');
    updateStatusBadge('status-grid-data', systemStatus.gridData.mode === 'live', 
      systemStatus.gridData.error || 'No echo repeater connection');
    updateStatusBadge('status-agents', systemStatus.agents.mode === 'live', 
      systemStatus.agents.error || 'No echo repeater connection');
    updateStatusBadge('status-devices', systemStatus.devices.mode === 'live', 
      systemStatus.devices.error || 'No echo repeater connection');
    updateStatusBadge('status-pulse', systemStatus.pulse.mode === 'live', 
      systemStatus.pulse.error || 'No echo repeater connection');
  }
  
  function updateStatusBadge(elementId, isConnected, errorMessage) {
    const badge = document.getElementById(elementId);
    if (!badge) return;
    
    if (isConnected) {
      badge.className = 'status-item-badge connected';
      badge.textContent = 'Connected';
    } else {
      badge.className = 'status-item-badge disconnected';
      badge.textContent = 'Unavailable';
      badge.title = errorMessage;
    }
  }
  
  // Update reconnection countdown
  function updateReconnectCountdown() {
    const countdownEl = document.getElementById('reconnect-countdown');
    const reconnectInfo = document.getElementById('reconnect-info');
    
    if (!systemStatus.backend.connected) {
      reconnectInfo.style.display = 'block';
      countdownEl.textContent = reconnectCountdown;
    } else {
      reconnectInfo.style.display = 'none';
    }
  }
  
  async function initializeBackendConnection() {
    // Attempt to connect via pulse modulation echo repeater
    // All backend operations go through echo repeater system
    systemStatus.backend.lastCheck = Date.now();
    
    try {
      console.log('[Echo Repeater] Initializing pulse modulation echo repeater connection...');
      const isHealthy = await checkAPIHealth();
      
      if (isHealthy) {
        console.log('[Echo Repeater] Pulse modulation echo repeater active');
        pushEvent('SYSTEM', 'Echo repeater active - Live data mode via pulse modulation', 'info');
        
        systemStatus.backend.connected = true;
        systemStatus.backend.error = null;
        systemStatus.gridData.mode = 'live';
        systemStatus.agents.mode = 'live';
        systemStatus.devices.mode = 'live';
        systemStatus.pulse.mode = 'live';
        backendAvailable = true;
        
        // Fetch initial data via echo repeater
        await fetchGridStateFromBackend();
      } else {
        throw new Error('Echo repeater health check failed');
      }
    } catch (error) {
      console.error('[Echo Repeater] Failed to connect via pulse modulation:', error);
      pushEvent('SYSTEM', 'Echo repeater not available - No data to display', 'warn');
      
      systemStatus.backend.connected = false;
      systemStatus.backend.error = `Cannot connect via echo repeater: ${error.message}`;
      systemStatus.gridData.mode = 'unavailable';
      systemStatus.agents.mode = 'unavailable';
      systemStatus.devices.mode = 'unavailable';
      systemStatus.pulse.mode = 'unavailable';
      backendAvailable = false;
    }
    
    updateSystemStatusDisplay();
    updateReconnectCountdown();
  }
  
  // Fetch grid state via pulse modulation echo repeater
  async function fetchGridStateFromBackend() {
    try {
      const gridState = await callGridAPI('/grid/state');
      console.log('[Echo Repeater] Received grid state:', gridState);
      
      // Validate and update local state with echo repeater data
      if (gridState && typeof gridState === 'object') {
        if (Array.isArray(gridState.nodes)) nodes = gridState.nodes;
        if (Array.isArray(gridState.links)) links = gridState.links;
        if (Array.isArray(gridState.agents)) agents = gridState.agents;
        if (Array.isArray(gridState.devices)) devices = gridState.devices;
        if (Array.isArray(gridState.alerts)) alerts = gridState.alerts;
        if (Array.isArray(gridState.panels)) electricalPanels = gridState.panels;
        if (Array.isArray(gridState.circuits)) circuits = gridState.circuits;
        
        updateMeta();
        renderEntityList();
        renderPanelList();
        
        pushEvent('SYSTEM', 'Grid state loaded via echo repeater', 'info');
      } else {
        throw new Error('Invalid grid state format from echo repeater');
      }
    } catch (error) {
      console.error('[Echo Repeater] Failed to fetch grid state:', error);
      pushEvent('SYSTEM', 'Failed to load grid state via echo repeater', 'warn');
      
      // Revert status since data fetch failed
      systemStatus.backend.connected = false;
      systemStatus.gridData.mode = 'unavailable';
      systemStatus.agents.mode = 'unavailable';
      systemStatus.devices.mode = 'unavailable';
      systemStatus.pulse.mode = 'unavailable';
      updateSystemStatusDisplay();
    }
  }
  //   const msg = JSON.parse(event.data);
  //   switch (msg.type) {
  //     case "topology":
  //       // update nodes/links
  //       break;
  //     case "agents":
  //       // update agents
  //       break;
  //     case "devices":
  //       // update devices
  //       break;
  //     case "wave":
  //       // update waveform meta / overlays
  //       break;
  //     case "event":
  //       pushEvent(msg.kind, msg.message, msg.severity);
  //       break;
  //   }
  //   updateMeta();
  //   renderEntityList();
  // };
})();

// Wake on LAN UI Integration
(function() {
  const wolClient = new WakeOnLANClient();
  
  const wolUI = {
    panel: document.getElementById('wol-panel'),
    form: document.getElementById('wol-form'),
    addBtn: document.getElementById('wol-add-btn'),
    deviceList: document.getElementById('wol-device-list'),
    serviceDot: document.getElementById('wol-service-dot'),
    serviceStatus: document.getElementById('wol-service-status'),
    
    togglePanel() {
      this.panel.classList.toggle('minimized');
    },
    
    toggleForm() {
      const isVisible = this.form.style.display !== 'none';
      this.form.style.display = isVisible ? 'none' : 'block';
      this.addBtn.style.display = isVisible ? 'block' : 'none';
      
      // Clear form if hiding
      if (isVisible) {
        document.getElementById('wol-name').value = '';
        document.getElementById('wol-mac').value = '';
        document.getElementById('wol-ip').value = '255.255.255.255';
        document.getElementById('wol-type').value = 'other';
        document.getElementById('wol-mac-error').textContent = '';
        document.getElementById('wol-mac').classList.remove('error');
      }
    },
    
    validateMACAddress(mac) {
      return wolClient.validateMACAddress(mac);
    },
    
    addDevice() {
      const name = document.getElementById('wol-name').value.trim();
      const mac = document.getElementById('wol-mac').value.trim();
      const ip = document.getElementById('wol-ip').value.trim() || '255.255.255.255';
      const type = document.getElementById('wol-type').value;
      const macError = document.getElementById('wol-mac-error');
      const macInput = document.getElementById('wol-mac');
      
      macError.textContent = '';
      macInput.classList.remove('error');
      
      if (!name) {
        alert('Please enter a device name');
        return;
      }
      
      if (!this.validateMACAddress(mac)) {
        macError.textContent = 'Invalid MAC address format. Use AA:BB:CC:DD:EE:FF';
        macInput.classList.add('error');
        return;
      }
      
      wolClient.addDevice({ name, macAddress: mac, ipAddress: ip, type });
      this.toggleForm();
      this.renderDevices();
      this.updateFridgeCount();
      
      pushEvent('WOL', `Device added: ${name} (${mac})`, 'info');
    },
    
    async wakeDevice(deviceId) {
      const device = wolClient.getDevice(deviceId);
      if (!device) return;
      
      try {
        pushEvent('WOL', `‚ö° Sending magic packet to ${device.name}...`, 'info');
        
        const result = await wolClient.wakeDevice(deviceId, {
          injectAI: true,
          waitForAck: true
        });
        
        if (result.success) {
          pushEvent('WOL', `‚úì Magic packet sent to ${device.name} (${device.macAddress})`, 'info');
          
          if (result.aiInjected) {
            pushEvent('WOL', `ü§ñ AI script deployed to ${device.name}`, 'info');
          }
          
          // Wait for acknowledgment
          if (result.acknowledgmentPending) {
            pushEvent('WOL', `‚è≥ Waiting for acknowledgment from ${device.name}...`, 'info');
            
            setTimeout(async () => {
              try {
                const heartbeat = await wolClient.getDeviceHeartbeat(deviceId);
                if (heartbeat.online) {
                  pushEvent('WOL', `‚úì ${device.name} is online and responding!`, 'info');
                  this.renderDevices();
                } else {
                  pushEvent('WOL', `‚ö† No response from ${device.name}`, 'warn');
                }
              } catch (error) {
                pushEvent('WOL', `‚ö† Could not verify ${device.name} status`, 'warn');
              }
            }, 5000);
          }
          
          this.renderDevices();
        } else {
          pushEvent('WOL', `‚úó Failed to wake ${device.name}: ${result.error}`, 'warn');
        }
      } catch (error) {
        pushEvent('WOL', `‚úó Error waking ${device.name}: ${error.message}`, 'warn');
        console.error('[WOL UI] Error:', error);
      }
    },
    
    removeDevice(deviceId) {
      const device = wolClient.getDevice(deviceId);
      if (!device) return;
      
      if (confirm(`Remove device "${device.name}"?`)) {
        wolClient.removeDevice(deviceId);
        this.renderDevices();
        this.updateFridgeCount();
        pushEvent('WOL', `Device removed: ${device.name}`, 'info');
      }
    },
    
    renderDevices() {
      const devices = wolClient.getDevices();
      
      if (devices.length === 0) {
        this.deviceList.innerHTML = '<div class="wol-empty">No devices configured. Add a device to get started.</div>';
        return;
      }
      
      this.deviceList.innerHTML = devices.map(device => {
        const statusClass = device.status === 'online' ? 'online' : device.status === 'waking' ? 'waking' : 'unknown';
        const statusIcon = device.status === 'online' ? 'üü¢' : device.status === 'waking' ? 'üü°' : '‚ö™';
        const aiIcon = device.aiInjected ? 'ü§ñ' : '';
        const ackIcon = device.acknowledged ? '‚úì' : '';
        const typeEmoji = this.getDeviceTypeEmoji(device.type);
        const typeLabel = this.getDeviceTypeLabel(device.type);
        
        return `
        <div class="wol-device-item">
          <div class="wol-device-info">
            <div class="wol-device-name">${statusIcon} ${typeEmoji} ${this.escapeHtml(device.name)} ${aiIcon} ${ackIcon}</div>
            <div class="wol-device-mac">${this.escapeHtml(device.macAddress)}</div>
            ${device.type ? `<div class="wol-device-status">Type: ${this.escapeHtml(typeLabel)}</div>` : ''}
            ${device.lastWake ? `<div class="wol-device-status">Last wake: ${new Date(device.lastWake).toLocaleTimeString()}</div>` : ''}
            ${device.status ? `<div class="wol-device-status">Status: ${device.status}</div>` : ''}
          </div>
          <div style="display: flex; gap: 4px; flex-direction: column;">
            <button class="wol-btn small" onclick="wolUI.wakeDevice('${device.id}')">‚ö° Wake</button>
            <button class="wol-btn small" onclick="wolUI.checkHeartbeat('${device.id}')">üíì Status</button>
            <button class="wol-btn small danger" onclick="wolUI.removeDevice('${device.id}')">√ó</button>
          </div>
        </div>
      `;
      }).join('');
    },
    
    async checkHeartbeat(deviceId) {
      const device = wolClient.getDevice(deviceId);
      if (!device) return;
      
      try {
        pushEvent('WOL', `üíì Checking heartbeat for ${device.name}...`, 'info');
        
        const heartbeat = await wolClient.getDeviceHeartbeat(deviceId);
        
        if (heartbeat.online) {
          pushEvent('WOL', `‚úì ${device.name} is online (${heartbeat.secondsSinceLastHeartbeat}s ago)`, 'info');
          this.updateDevice(deviceId, {
            status: 'online',
            lastHeartbeat: heartbeat.lastHeartbeat
          });
        } else {
          pushEvent('WOL', `‚ö† ${device.name} is offline or not responding`, 'warn');
          this.updateDevice(deviceId, {
            status: 'offline'
          });
        }
        
        this.renderDevices();
      } catch (error) {
        pushEvent('WOL', `‚úó Error checking ${device.name}: ${error.message}`, 'warn');
        console.error('[WOL UI] Heartbeat check error:', error);
      }
    },
    
    updateDevice(deviceId, updates) {
      wolClient.updateDevice(deviceId, updates);
      this.renderDevices();
    },
    
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    },
    
    getDeviceTypeEmoji(type) {
      const emojiMap = {
        fridge: 'üßä',
        tv: 'üì∫',
        computer: 'üíª',
        phone: 'üì±',
        tablet: 'üì≤',
        printer: 'üñ®Ô∏è',
        router: 'üì°',
        camera: 'üì∑',
        speaker: 'üîä',
        other: 'üì¶'
      };
      return emojiMap[type] || 'üì¶';
    },
    
    getDeviceTypeLabel(type) {
      const labelMap = {
        fridge: 'Fridge/Refrigerator',
        tv: 'TV',
        computer: 'Computer',
        phone: 'Phone',
        tablet: 'Tablet',
        printer: 'Printer',
        router: 'Router',
        camera: 'Camera',
        speaker: 'Speaker',
        other: 'Other'
      };
      return labelMap[type] || 'Other';
    },
    
    updateFridgeCount() {
      const devices = wolClient.getDevices();
      const fridgeCount = devices.filter(d => d.type === 'fridge').length;
      const fridgeCountEl = document.getElementById('fridge-count');
      if (fridgeCountEl) {
        fridgeCountEl.textContent = fridgeCount;
      }
    },
    
    async checkService() {
      try {
        const isHealthy = await wolClient.checkServiceHealth();
        
        if (isHealthy) {
          this.serviceDot.classList.add('online');
          this.serviceDot.classList.remove('offline');
          this.serviceStatus.textContent = 'Backend service online';
        } else {
          this.serviceDot.classList.remove('online');
          this.serviceDot.classList.add('offline');
          this.serviceStatus.textContent = 'Backend service offline';
        }
      } catch (error) {
        this.serviceDot.classList.remove('online');
        this.serviceDot.classList.add('offline');
        this.serviceStatus.textContent = 'Backend service offline';
        console.error('[WOL UI] Service check error:', error);
      }
    },
    
    init() {
      this.renderDevices();
      this.updateFridgeCount();
      this.checkService();
      
      // Check service health every 30 seconds
      setInterval(() => this.checkService(), 30000);
      
      console.log('[WOL UI] Initialized with', wolClient.getDevices().length, 'devices');
    }
  };
  
  // Make wolUI globally accessible
  window.wolUI = wolUI;
  
  // Initialize on load
  wolUI.init();
})();

// ============================================================================
// ICE MELTING SYSTEM FOR POWER LINE DE-ICING
// ============================================================================
(function() {
  'use strict';
  
  /**
   * Power Line Ice Melting System
   * Implements three de-icing methods:
   * 1. Controlled Short-Circuit (Joule Heating)
   * 2. Variable Resistance Cables (VRC)
   * 3. Heat-Trace Cables
   * 
   * Monitors ice thickness, line temperature, and weather conditions
   * Automatically activates de-icing when needed to prevent power line collapse
   */
  
  const iceMeltingSystem = {
    // Current state
    iceThickness: 0.0,         // inches
    lineTemperature: 32,       // Fahrenheit
    stormSeverity: 0,          // 0-5 scale
    stormName: 'None',
    
    // De-icing methods status
    shortCircuitActive: false,
    vrcActive: false,
    heatTraceActive: false,
    autoModeEnabled: false,
    
    // Thresholds
    AUTO_ACTIVATION_THRESHOLD: 0.5,  // inches - activate when ice exceeds this
    CRITICAL_ICE_THRESHOLD: 2.0,     // inches - critical danger level
    SAFE_TEMPERATURE_RANGE: [32, 35], // ¬∞F - safe range above freezing
    
    // Ice accumulation and melt rates (inches per second)
    ICE_ACCUMULATION_RATE_BASE: 0.001, // Base rate per storm severity level
    NATURAL_MELT_RATE: 0.0005,         // Natural melting above freezing
    SHORT_CIRCUIT_MELT_RATE: 0.008,    // Controlled current injection method
    VRC_MELT_RATE: 0.005,               // Variable resistance cable method
    HEAT_TRACE_MELT_RATE: 0.003,       // Heat-trace cable method
    
    // Performance metrics
    totalIceMelted: 0,
    deicingOperations: 0,
    energyUsed: 0, // kWh
    
    // DOM elements
    iceThicknessEl: document.getElementById('ice-thickness'),
    lineTempEl: document.getElementById('line-temp'),
    stormStatusEl: document.getElementById('storm-status'),
    deicingStatusEl: document.getElementById('deicing-status'),
    iceThicknessTagEl: document.getElementById('ice-thickness-tag'),
    lineTempTagEl: document.getElementById('line-temp-tag'),
    stormStatusTagEl: document.getElementById('storm-status-tag'),
    deicingStatusTagEl: document.getElementById('deicing-status-tag'),
    deicingLogEl: document.getElementById('deicing-log'),
    shortCircuitBtn: document.getElementById('short-circuit-btn'),
    vrcBtn: document.getElementById('vrc-btn'),
    heatTraceBtn: document.getElementById('heat-trace-btn'),
    autoModeBtn: document.getElementById('auto-mode-btn'),
    
    init() {
      console.log('[Ice Melting] System initializing...');
      
      // Start monitoring loop
      this.startMonitoring();
      
      // Simulate incoming storm (as per problem statement)
      setTimeout(() => {
        this.simulateStorm('Major Ice Storm', 4, 3.0);
      }, 5000);
      
      this.log('‚úì Ice melting system initialized', 'info');
      this.log('‚ö† System ready to protect power lines from ice buildup', 'info');
    },
    
    startMonitoring() {
      // Update every second
      setInterval(() => {
        this.updateConditions();
        this.checkAutoActivation();
        this.updateDisplay();
      }, 1000);
    },
    
    updateConditions() {
      const now = Date.now();
      
      // Simulate weather effects
      if (this.stormSeverity > 0) {
        // Ice accumulation during storm
        const iceRate = this.stormSeverity * this.ICE_ACCUMULATION_RATE_BASE;
        this.iceThickness += iceRate;
        
        // Temperature drop during storm
        this.lineTemperature = Math.max(15, 32 - (this.stormSeverity * 3));
      } else {
        // Natural melting when above freezing
        if (this.lineTemperature > 32 && this.iceThickness > 0) {
          this.iceThickness = Math.max(0, this.iceThickness - this.NATURAL_MELT_RATE);
        }
      }
      
      // Apply de-icing effects
      if (this.shortCircuitActive) {
        this.applyShortCircuitHeating();
      }
      if (this.vrcActive) {
        this.applyVRCHeating();
      }
      if (this.heatTraceActive) {
        this.applyHeatTraceHeating();
      }
    },
    
    checkAutoActivation() {
      if (!this.autoModeEnabled) return;
      
      // Auto-activate when ice exceeds threshold
      if (this.iceThickness >= this.AUTO_ACTIVATION_THRESHOLD) {
        if (!this.shortCircuitActive && !this.vrcActive && !this.heatTraceActive) {
          this.log('ü§ñ AUTO MODE: Ice threshold exceeded, activating current injection heating', 'warn');
          this.activateShortCircuit(true);
        }
      }
      
      // Critical alert
      if (this.iceThickness >= this.CRITICAL_ICE_THRESHOLD) {
        this.log('üö® CRITICAL: Ice thickness at dangerous levels! All de-icing methods activated!', 'danger');
        if (!this.shortCircuitActive) this.activateShortCircuit(true);
        if (!this.vrcActive) this.activateVRC(true);
        if (!this.heatTraceActive) this.activateHeatTrace(true);
      }
    },
    
    activateShortCircuit(autoActivated = false) {
      if (this.shortCircuitActive) {
        // Deactivate
        this.shortCircuitActive = false;
        this.shortCircuitBtn.classList.remove('danger-active');
        this.log('‚ùå Current injection heating deactivated', 'info');
      } else {
        // Activate
        this.shortCircuitActive = true;
        this.shortCircuitBtn.classList.add('danger-active');
        this.deicingOperations++;
        
        const mode = autoActivated ? '(AUTO)' : '(MANUAL)';
        this.log(`üî• Current injection heating activated ${mode}`, 'info');
        this.log('   Method: Controlled current injection increases conductor temperature', 'info');
        this.log('   Effect: Joule heating warms conductor to melt ice', 'info');
        this.log('   Power: 150-300 kW per mile of line', 'warn');
      }
      
      this.updateDeicingStatus();
    },
    
    activateVRC(autoActivated = false) {
      if (this.vrcActive) {
        // Deactivate
        this.vrcActive = false;
        this.vrcBtn.classList.remove('active');
        this.log('‚ùå VRC heating deactivated', 'info');
      } else {
        // Activate
        this.vrcActive = true;
        this.vrcBtn.classList.add('active');
        this.deicingOperations++;
        
        const mode = autoActivated ? '(AUTO)' : '(MANUAL)';
        this.log(`‚ö° Variable Resistance Cable heating activated ${mode}`, 'info');
        this.log('   Method: Switch line resistance from low to high', 'info');
        this.log('   Effect: Increased resistance generates heat in conductor', 'info');
        this.log('   Power: 100-200 kW per mile of line', 'warn');
      }
      
      this.updateDeicingStatus();
    },
    
    activateHeatTrace(autoActivated = false) {
      if (this.heatTraceActive) {
        // Deactivate
        this.heatTraceActive = false;
        this.heatTraceBtn.classList.remove('active');
        this.log('‚ùå Heat-trace cables deactivated', 'info');
      } else {
        // Activate
        this.heatTraceActive = true;
        this.heatTraceBtn.classList.add('active');
        this.deicingOperations++;
        
        const mode = autoActivated ? '(AUTO)' : '(MANUAL)';
        this.log(`üå°Ô∏è Heat-trace cable system activated ${mode}`, 'info');
        this.log('   Method: Dedicated electric cables along power lines', 'info');
        this.log('   Effect: Self-regulating heat output prevents ice formation', 'info');
        this.log('   Power: 50-100 kW per mile of line', 'warn');
      }
      
      this.updateDeicingStatus();
    },
    
    toggleAutoMode() {
      this.autoModeEnabled = !this.autoModeEnabled;
      
      if (this.autoModeEnabled) {
        this.autoModeBtn.textContent = 'ü§ñ Auto Mode: ON';
        this.autoModeBtn.classList.add('active');
        this.log('ü§ñ Automatic de-icing mode ENABLED', 'info');
        this.log(`   Will activate when ice exceeds ${this.AUTO_ACTIVATION_THRESHOLD}" threshold`, 'info');
      } else {
        this.autoModeBtn.textContent = 'ü§ñ Auto Mode: OFF';
        this.autoModeBtn.classList.remove('active');
        this.log('‚ùå Automatic de-icing mode DISABLED', 'info');
      }
    },
    
    applyShortCircuitHeating() {
      // Current injection heating is most powerful
      this.iceThickness = Math.max(0, this.iceThickness - this.SHORT_CIRCUIT_MELT_RATE);
      this.lineTemperature = Math.min(this.lineTemperature + 0.5, 65);
      this.energyUsed += 0.05; // kWh
      this.totalIceMelted += this.SHORT_CIRCUIT_MELT_RATE;
    },
    
    applyVRCHeating() {
      // VRC is moderately powerful
      this.iceThickness = Math.max(0, this.iceThickness - this.VRC_MELT_RATE);
      this.lineTemperature = Math.min(this.lineTemperature + 0.3, 55);
      this.energyUsed += 0.03; // kWh
      this.totalIceMelted += this.VRC_MELT_RATE;
    },
    
    applyHeatTraceHeating() {
      // Heat-trace is steady but less powerful
      this.iceThickness = Math.max(0, this.iceThickness - this.HEAT_TRACE_MELT_RATE);
      this.lineTemperature = Math.min(this.lineTemperature + 0.2, 45);
      this.energyUsed += 0.02; // kWh
      this.totalIceMelted += this.HEAT_TRACE_MELT_RATE;
    },
    
    simulateStorm(name, severity, targetIce) {
      this.stormName = name;
      this.stormSeverity = severity;
      
      this.log(`üå®Ô∏è STORM ALERT: ${name} approaching!`, 'danger');
      this.log(`   Severity: ${severity}/5`, 'danger');
      this.log(`   Forecast: Up to ${targetIce}" of ice accumulation`, 'danger');
      this.log(`   ‚ö† THIS IS A REAL FORECASTED EVENT`, 'danger');
      this.log(`   ‚ö† Power line protection is CRITICAL`, 'danger');
      
      // Storm duration: simulate for a period then clear
      setTimeout(() => {
        this.stormSeverity = Math.max(0, this.stormSeverity - 1);
        if (this.stormSeverity > 0) {
          setTimeout(() => this.simulateStorm(name, this.stormSeverity, targetIce), 30000);
        } else {
          this.stormName = 'Clearing';
          this.log('‚úì Storm passing, conditions improving', 'info');
          setTimeout(() => {
            this.stormName = 'None';
            this.log('‚úì Storm cleared', 'info');
          }, 10000);
        }
      }, 30000);
    },
    
    updateDeicingStatus() {
      const activeMethods = [];
      if (this.shortCircuitActive) activeMethods.push('Current Injection');
      if (this.vrcActive) activeMethods.push('VRC');
      if (this.heatTraceActive) activeMethods.push('Heat-Trace');
      
      if (activeMethods.length > 0) {
        this.deicingStatusEl.textContent = activeMethods.join(' + ');
        this.deicingStatusTagEl.classList.add('active');
        this.deicingStatusTagEl.style.background = 'rgba(245, 101, 101, 0.2)';
        this.deicingStatusTagEl.style.borderColor = 'var(--danger)';
      } else {
        this.deicingStatusEl.textContent = 'Standby';
        this.deicingStatusTagEl.classList.remove('active');
        this.deicingStatusTagEl.style.background = 'rgba(79, 209, 197, 0.1)';
        this.deicingStatusTagEl.style.borderColor = '';
      }
    },
    
    updateDisplay() {
      // Update ice thickness
      this.iceThicknessEl.textContent = this.iceThickness.toFixed(2);
      
      // Color code based on severity
      if (this.iceThickness >= this.CRITICAL_ICE_THRESHOLD) {
        this.iceThicknessTagEl.style.background = 'rgba(245, 101, 101, 0.3)';
        this.iceThicknessTagEl.style.borderColor = 'var(--danger)';
        this.iceThicknessTagEl.style.color = 'var(--danger)';
      } else if (this.iceThickness >= this.AUTO_ACTIVATION_THRESHOLD) {
        this.iceThicknessTagEl.style.background = 'rgba(236, 201, 75, 0.3)';
        this.iceThicknessTagEl.style.borderColor = 'var(--warn)';
        this.iceThicknessTagEl.style.color = 'var(--warn)';
      } else {
        this.iceThicknessTagEl.style.background = '';
        this.iceThicknessTagEl.style.borderColor = '';
        this.iceThicknessTagEl.style.color = '';
      }
      
      // Update temperature
      this.lineTempEl.textContent = Math.round(this.lineTemperature);
      
      if (this.lineTemperature < 32) {
        this.lineTempTagEl.style.background = 'rgba(99, 179, 237, 0.3)';
        this.lineTempTagEl.style.borderColor = 'var(--node)';
      } else {
        this.lineTempTagEl.style.background = '';
        this.lineTempTagEl.style.borderColor = '';
      }
      
      // Update storm status
      this.stormStatusEl.textContent = this.stormName + (this.stormSeverity > 0 ? ` (${this.stormSeverity}/5)` : '');
      
      if (this.stormSeverity >= 4) {
        this.stormStatusTagEl.style.background = 'rgba(245, 101, 101, 0.3)';
        this.stormStatusTagEl.style.borderColor = 'var(--danger)';
        this.stormStatusTagEl.style.color = 'var(--danger)';
      } else if (this.stormSeverity >= 2) {
        this.stormStatusTagEl.style.background = 'rgba(236, 201, 75, 0.3)';
        this.stormStatusTagEl.style.borderColor = 'var(--warn)';
        this.stormStatusTagEl.style.color = 'var(--warn)';
      } else {
        this.stormStatusTagEl.style.background = '';
        this.stormStatusTagEl.style.borderColor = '';
        this.stormStatusTagEl.style.color = '';
      }
    },
    
    log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = document.createElement('div');
      logEntry.style.marginBottom = '4px';
      logEntry.style.paddingBottom = '4px';
      logEntry.style.borderBottom = '1px solid rgba(255, 255, 255, 0.05)';
      
      if (type === 'danger') {
        logEntry.style.color = 'var(--danger)';
      } else if (type === 'warn') {
        logEntry.style.color = 'var(--warn)';
      } else if (type === 'info') {
        logEntry.style.color = 'var(--text)';
      }
      
      logEntry.innerHTML = `<span style="color: var(--muted);">[${timestamp}]</span> ${message}`;
      
      this.deicingLogEl.insertBefore(logEntry, this.deicingLogEl.firstChild);
      
      // Keep only last 20 entries
      while (this.deicingLogEl.children.length > 20) {
        this.deicingLogEl.removeChild(this.deicingLogEl.lastChild);
      }
    }
  };
  
  // Make globally accessible
  window.iceMeltingSystem = iceMeltingSystem;
  
  // Initialize when page loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => iceMeltingSystem.init());
  } else {
    iceMeltingSystem.init();
  }
  
  console.log('[Ice Melting] Module loaded successfully');
})();

// ============================================================================
// POWERLINE COMMUNICATION (PLC) DEVICE DATA INTEGRATION
// ============================================================================
(function() {
  'use strict';
  
  let plcSystemReady = false;
  let plcDevices = [];
  
  // Wait for PLC system to be ready
  function initPLCIntegration() {
    if (typeof window.plcSystem === 'undefined') {
      console.log('[Grid Console] Waiting for PLC system...');
      setTimeout(initPLCIntegration, 500);
      return;
    }
    
    plcSystemReady = true;
    console.log('[Grid Console] PLC system connected - device data available');
    
    // Listen to PLC events
    window.plcSystem.on('initialized', (data) => {
      console.log('[Grid Console] PLC initialized:', data);
      
      // Show connection status
      const mode = data.mode || 'local';
      const isBackend = data.backendConnected;
      
      if (mode === 'networked') {
        pushEvent('SYSTEM', '‚úì Cloud sync enabled - Enhanced functionality active', 'info');
      } else {
        pushEvent('SYSTEM', '‚úì System operational - Running in standalone mode', 'info');
      }
      
      updateDeviceList();
    });
    
    window.plcSystem.on('network-discovered', (data) => {
      console.log('[Grid Console] Network discovered:', data.deviceCount, 'devices');
      plcDevices = data.devices;
      updateDeviceList();
      
      const source = data.source || 'local';
      pushEvent('PLC', `üì° Discovered ${data.deviceCount} devices on power grid network`, 'info');
    });
    
    window.plcSystem.on('telemetry-update', (data) => {
      updateDeviceTelemetry(data);
    });
    
    window.plcSystem.on('device-discovered', (data) => {
      console.log('[Grid Console] New device:', data.device.name);
      pushEvent('PLC', `üîå New device: ${data.device.name}`, 'info');
      updateDeviceList();
    });
    
    window.plcSystem.on('device-offline', (data) => {
      console.log('[Grid Console] Device offline:', data.device.name);
      pushEvent('PLC', `‚ö†Ô∏è Device offline: ${data.device.name}`, 'warn');
      updateDeviceList();
    });
    
    // Initial load
    if (window.plcSystem.initialized) {
      updateDeviceList();
    }
  }
  
  // Update device list display
  function updateDeviceList() {
    if (!plcSystemReady || !window.plcSystem) return;
    
    const devices = Array.from(window.plcSystem.devices.values());
    const stats = window.plcSystem.getNetworkStatistics();
    
    // Update main status
    const syncStatus = stats.backendConnected ? '‚òÅ Cloud Sync' : 'üì° Standalone';
    document.getElementById('main-status-text').textContent = 
      `${stats.onlineDevices} Devices Online (${stats.totalDevices} total) ‚Ä¢ ${syncStatus}`;
    
    // Add PLC devices to the network nodes display
    displayPLCDevices(devices, stats);
  }
  
  // Display PLC devices in the UI
  function displayPLCDevices(devices, stats) {
    // Find or create device list container
    let deviceListContainer = document.getElementById('plc-device-list');
    
    // Determine connection status
    const modeInfo = stats && stats.mode ? stats : { mode: 'local', backendConnected: false };
    const statusText = modeInfo.backendConnected ? '‚òÅ CLOUD SYNCED' : 'üì° STANDALONE';
    const statusColor = modeInfo.backendConnected ? 'var(--accent)' : 'var(--ok)';
    
    if (!deviceListContainer) {
      // Create a new panel for PLC devices
      const sidePanel = document.getElementById('side-panel');
      if (sidePanel) {
        const devicePanel = document.createElement('div');
        devicePanel.className = 'panel';
        devicePanel.innerHTML = `
          <div class="panel-title">
            <span class="label">‚ö° ELECTRICAL NETWORK DEVICES</span>
            <span class="value" id="plc-device-count">0 devices</span>
          </div>
          <div style="font-size: 0.65rem; padding: 4px 12px; margin: -4px 0 8px; border-radius: 4px; background: ${statusColor}20; color: ${statusColor}; border: 1px solid ${statusColor};">
            <span id="plc-mode-indicator">${statusText}</span>
          </div>
          <div id="plc-device-list" style="max-height: 300px; overflow-y: auto;">
            <div style="text-align: center; padding: 20px; color: var(--muted); font-size: 0.75rem;">
              Loading device data...
            </div>
          </div>
        `;
        sidePanel.insertBefore(devicePanel, sidePanel.firstChild);
        deviceListContainer = document.getElementById('plc-device-list');
      }
    }
    
    // Update status indicator if it exists
    const statusIndicator = document.getElementById('plc-mode-indicator');
    if (statusIndicator) {
      statusIndicator.textContent = statusText;
      statusIndicator.parentElement.style.background = `${statusColor}20`;
      statusIndicator.parentElement.style.color = statusColor;
      statusIndicator.parentElement.style.borderColor = statusColor;
    }
    
    if (!deviceListContainer) return;
    
    // Update device count
    const deviceCountEl = document.getElementById('plc-device-count');
    if (deviceCountEl) {
      deviceCountEl.textContent = `${devices.length} devices`;
    }
    
    // Render device list
    if (devices.length === 0) {
      deviceListContainer.innerHTML = `
        <div style="text-align: center; padding: 20px; color: var(--muted); font-size: 0.75rem;">
          No devices detected on electrical network
        </div>
      `;
      return;
    }
    
    const html = devices.map(device => {
      const statusColor = device.status === 'online' ? 'var(--ok)' : 'var(--danger)';
      const statusText = device.status === 'online' ? 'ONLINE' : 'OFFLINE';
      
      let metricsHTML = '';
      if (device.telemetry) {
        const metrics = Object.entries(device.telemetry).slice(0, 3).map(([key, value]) => {
          let displayValue = typeof value === 'number' ? value.toFixed(1) : value;
          let unit = '';
          
          if (key === 'voltage') unit = 'V';
          else if (key === 'current') unit = 'A';
          else if (key === 'power') unit = 'W';
          else if (key === 'temperature') unit = '¬∞C';
          else if (key === 'battery') unit = '%';
          else if (key === 'brightness') unit = '%';
          
          return `<span style="font-size: 0.65rem; color: var(--muted);">${key}: ${displayValue}${unit}</span>`;
        }).join(' | ');
        
        metricsHTML = `<div style="margin-top: 4px;">${metrics}</div>`;
      }
      
      return `
        <div style="
          background: rgba(15, 23, 42, 0.5);
          border: 1px solid rgba(148, 163, 184, 0.2);
          border-radius: 6px;
          padding: 8px;
          margin-bottom: 6px;
          font-size: 0.75rem;
        ">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <span style="font-size: 1rem;">${device.icon}</span>
              <strong style="margin-left: 6px;">${device.name}</strong>
            </div>
            <span style="
              font-size: 0.65rem;
              padding: 2px 6px;
              border-radius: 999px;
              background: ${statusColor}20;
              color: ${statusColor};
              border: 1px solid ${statusColor};
            ">${statusText}</span>
          </div>
          <div style="margin-top: 4px; font-size: 0.65rem; color: var(--muted);">
            ${device.location} ‚Ä¢ ${device.powerLine}
          </div>
          ${metricsHTML}
        </div>
      `;
    }).join('');
    
    deviceListContainer.innerHTML = html;
  }
  
  // Update device telemetry
  function updateDeviceTelemetry(telemetryData) {
    // This would update real-time values in the device cards
    // For now, we'll just trigger a refresh
    if (window.plcSystem && window.plcSystem.devices) {
      const devices = Array.from(window.plcSystem.devices.values());
      displayPLCDevices(devices);
    }
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPLCIntegration);
  } else {
    initPLCIntegration();
  }
  
  console.log('[Grid Console] PLC integration module loaded');
})();

// =============================================================================
// PHASE 1-5: AI GRID LINK ENHANCEMENT AGENTS
// =============================================================================

(function() {
  console.log('[Grid Console] Initializing enhancement agents...');
  
  // Wait for PLC system to be ready
  function initEnhancementAgents() {
    // Phase 1: Mobile Power Grid Agent
    if (window.MobilePowerGridAgent) {
      window.mobilePowerAgent = new MobilePowerGridAgent();
      
      // Listen for power source changes
      window.mobilePowerAgent.on('source-changed', (data) => {
        console.log('[Grid Console] Power source changed:', data);
        pushEvent('POWER', `‚ö° ${data.newSource === 'charging' ? 'Plugged in' : 'On battery'} - Switched to ${data.dataSource} data`, 'info');
      });
      
      window.mobilePowerAgent.on('battery-update', (data) => {
        // Update UI with battery status if needed
        if (data.level < 0.2) {
          pushEvent('POWER', `üîã Low battery: ${(data.level * 100).toFixed(0)}%`, 'warn');
        }
      });
      
      console.log('[Grid Console] ‚úì Mobile Power Grid Agent initialized');
    }
    
    // Phase 2: Device Identification Agent  
    if (window.DeviceIdentificationAgent) {
      window.deviceIdentAgent = new DeviceIdentificationAgent();
      
      // Listen for device identification
      window.deviceIdentAgent.on('device-identified', (data) => {
        console.log('[Grid Console] Device identified:', data);
        const confidence = (data.identification.confidence * 100).toFixed(1);
        pushEvent('DEVICE', `üîç Identified: ${data.deviceName} ‚Üí ${data.identification.type.name} (${confidence}%)`, 'info');
      });
      
      window.deviceIdentAgent.on('unknown-device', (data) => {
        console.log('[Grid Console] Unknown device detected:', data);
        pushEvent('DEVICE', `‚ùì Unknown device: ${data.deviceName} (Learning mode active)`, 'warn');
      });
      
      console.log('[Grid Console] ‚úì Device Identification Agent initialized');
    }
    
    // Phase 3: Echo Script Injection Agent
    if (window.EchoScriptInjectionAgent) {
      window.echoScriptAgent = new EchoScriptInjectionAgent();
      
      // Listen for script events
      window.echoScriptAgent.on('script-completed', (data) => {
        console.log('[Grid Console] Script completed:', data);
        pushEvent('SCRIPT', `‚úì Script executed: ${data.scriptId} (${data.executionTime}ms)`, 'success');
      });
      
      window.echoScriptAgent.on('script-failed', (data) => {
        console.log('[Grid Console] Script failed:', data);
        pushEvent('SCRIPT', `‚úó Script failed: ${data.scriptId} - ${data.error}`, 'error');
      });
      
      window.echoScriptAgent.on('script-warnings', (data) => {
        console.log('[Grid Console] Script warnings:', data);
        pushEvent('SCRIPT', `‚ö† Script warnings: ${data.warnings.join(', ')}`, 'warn');
      });
      
      console.log('[Grid Console] ‚úì Echo Script Injection Agent initialized');
    }
    
    // Emit initialization event
    const event = new CustomEvent('agents-initialized', {
      detail: {
        mobilePower: !!window.mobilePowerAgent,
        deviceIdent: !!window.deviceIdentAgent,
        echoScript: !!window.echoScriptAgent
      }
    });
    document.dispatchEvent(event);
    
    console.log('[Grid Console] ‚úì All enhancement agents initialized');
  }
  
  // Initialize when PLC system is ready
  if (window.plcSystem && window.plcSystem.initialized) {
    initEnhancementAgents();
  } else {
    document.addEventListener('plc:initialized', initEnhancementAgents);
  }
  
  console.log('[Grid Console] Enhancement agents module loaded');
})();
</script>
    <script src="/js/universal-utilities.js"></script>

    <!-- Universal Navigation - Added by Project Fixer -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof BarbrickUniversal !== 'undefined') {
                // Only add navigation if not already present
                if (!document.querySelector('.universal-header')) {
                    BarbrickUniversal.createBackButton();
                }
                
                // Add footer if not present
                if (!document.querySelector('.universal-footer')) {
                    BarbrickUniversal.createFooter();
                }
            }
        });
    </script>
</body>
</html>
